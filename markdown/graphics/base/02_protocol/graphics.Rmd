---
title: "A deeper dive into graphing in base R"
---

Compiled on `r format(Sys.time(), format = "%e %B %Y %H:%M")`.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
sec1 = 0
```

Typical tutorials on graphing in R aim to rapidly develop understanding of higher level graphing functions to get users generating useful graphs quickly. While this approach has merit in certain use cases, it tends to gloss over the lower level understanding of detail on how high level graphing functions work. This lack of detail limits the creativity with which a user is able to create graphs not supported by the higher level functions or the specificity with which a user can make a graphical rendering look exactly as desired. Lack of detail also limits the skill with which a user can troubleshoot graphing code that does not render as expected.

This tutorial is designed to provide a deeper dive into graphing with base R functions. It first reviews the basics of graphics devices, then progresses to build scaffolding of examples with increasing levels of detail into how graphing is implemented in base R. While the tutorial attempts to build in complexity and detail one step at a time, some familiarity with the manipulation of fundamental data types and the operation of functions in R is probably necessary to take full advantage of this tutorial. Completing a higher level tutorial on graphing in base R before working through this more detailed tutorial may be an effective strategy.

The reader should also be prepared to experiment with an open session in R (perhaps starting with code copied from this document) to take full advantage of the tutorial. Challenging yourself to predict what a function will do if you change an argument, and then testing that prediction with your own code, is an effective way to self-assess complete understanding of these skills and principles presented here. Ongoing learning of the R functions that allow exploration of the data structures of arguments to R functions and the return values from R functions is highly recommended for rapid progress in R programming and debugging skill.

This tutorial focuses on graphics tools typically loaded by default in an R session, including the **grDevices** package and the **graphics** package. Not covered here are a family of tools based on the  **grid** graphics package that is an alternative implementation of the **graphics** package and thus provides an alternative interface to creating graphical objects. Popular higher level graphing tools that use **grid** include the **lattice** and **ggplot2** packages. A full understanding of **grid** with the conveniences of **lattice** or **ggplot2** are another way to take full control over the appearance of complex data visualizations.


# `r sec1 <- sec1 + 1; sec2 <- 0; sec1`. Graphics devices

Opening a graphics device creates a blank canvas upon which graphs will be rendered. The most common graphing tools in R (including base R, grid, and ggplot) all use the same canvas provided by a given graphics device. Therefore, if you understand the details of how to control the specific areas of the canvas that are used by a given graphing tool, you can combine or overlap the results of any or all of these tools on the same canvas.

Graphics devices are designed to have a common interface for the functions used to add symbols to the graphs. Ideally, calling a given graphing function should create the same rendered visualization regardless of which device is in use. This feature provides the modularity that a given block of graphing code should create the same image regardless of using a device that renders it on the screen, renders it to a raster image file, or renders it to a vector graphics format. This degree of modularity is seldom fully realized. Particular devices may not have all the features necessary to render all aspects of a given graphing tool. For example, identical fonts or font sizes may not be available across all graphics devices, and transparency in colors will not render properly on all devices. You should expect differences between how different devices plot the same graph, so early consideration of the appropriate device that generates the proper format for the final product is encouraged.

A default device (called the "null device") is likely automatically open in R, where the device used as default depends upon the platform you are using for development. In RStudio, the default device typically renders to the "Plots" tab, which is typically available in the bottom right panel. The device that renders to the "Plots" tab is convenient, but the size and aspect ratio of graphs rendered in this panel will change depending on how your RStudio window is configured. This lack of consistency in size and aspect ratio is problematic when refining figures or sharing code that generates figures, and use of an external device that allows consistency through programmatic control over the dimensions of the figure is suggested.

The full array of available graphics devices cannot be demonstrated directly in an Rmarkdown file, because the compiler for R Markdown uses a specific device that embeds the resulting rendered graphics in the compiled document. However, a few examples of useful graphics devices are briefly outlined here, and experimentation with these devices is encouraged to understand the available options for figure development.


## `r sec1`.`r sec2 <- sec2 + 1; sec2`. Rendering graphs to postscript vector graphics

A useful device directly renders graphics to a file in vectorized postscript format (e.g., Adobe PDF files), and works on both Mac and PC computing platforms (as well as many others). The ` pdf() ` function is used to open this graphics device. Key arguments to the ` pdf() ` function allow direct programmatic control over the basic size and default font point size for a given canvas. The following code generates a sample PDF file, if run in an R session with the working directory set to where the file should be written. You are encouraged to cut and paste this code into an R script, and experiment with running the script with different values for the arguments to confirm you understand the behaviors they control. Note that the script may not run properly if you have the resulting graphics file open in a PDF viewer, if your PDF viewer locks the file. SumatraPDF is a useful PDF viewer for development in Windows because it does not lock the file and automatically updates your view of the PDF file if it is rewritten by your R script.

``` 
# Shut down any existing devices
graphics.off()

# Open the PDF graphics device 
pdf(
  file = "./graphics_test.pdf",
  width = 6,
  height = 5,
  pointsize = 12
)

# Plot points at coordinates 0, 0 and 1, 1
plot(
  x = c(0, 1),
  xlab = "x",
  y = c(0, 1),
  ylab = "y"
)

# Terminate the graphics device
dev.off()
```
Description of functions and arguments being used for the first time:

- ` graphics.off() `: Closes all graphics devices opened previously. Calling this before starting a new graph is particularly useful when debugging code and graphics devices might have been left open due to a fatal error in a previous execution of a script. For devices that write to a file, previously opened devices writing to the same file name will likely cause this code to fail because the file cannot be overwritten if it is currently open.
- ` pdf() `: Opens a graphics device that writes to a postscript file
    - ` file `: Path to the file where the graphics will be written
        - ` "./graphics_test.pdf" `: Results in the file "graphics_test.pdf" being written to the working directory.
    - ` width `: Width of the canvas where graphical elements can be added
        - ` 6 `: Width of the canvas will be 6 inches
    - ` height `: Height of the canvas where graphical elements can be added
        - ` 5 `: Height of the canvas will b 5 inches
    - ` pointsize `: The default point size of characters and symbols
        - ` 12 `: Renderer will use a 12 point font for characters (12/72 = 1/6 of an inch). You might note from the documentation of ` pdf() ` that 12 is the default value for this argument. Therefore, the same result would be obtained if this argument were removed from the function call.
- ` plot() ` : A high level function for creating a new plot with a single line of code
    - ` x `: Numerical vector of values for the x coordinate of each data point graphed
        - ` c(...) `: A function returning a numerical vector with the x coordinates (see below)
    - ` xlab `: Character string to use as the label for the x axis
        - ` "x" `: x axis will be labeled with "x"
    - ` y `: Numerical vector of values for the y coordinate of each data point graphed
        - ` c(...) `: A function returning a numerical vector with the y coordinates (see below)
    - ` ylab `: Character string to use as the label for the y axis
        - ` "y" `: y axis will be labeled with "y"
- ` c() `: A general concatenation function
    - ` 0, 1 `: Providing a collection of numbers to the generic arguments of the ` c() ` function results in a numeric atomic vector being returned with elements containing values corresponding to the numbers provided (in this case, a vector with two elements containing the values 0 and 1)
- ` dev.off() `: Closes the most recently opened graphics device. For devices that write to a file (like ` pdf() `), this typically needs to be called for the file to be written to the disk and available to be opened by other applications.


## `r sec1`.`r sec2 <- sec2 + 1; sec2`. Graphing in Rmarkdown

When Rmarkdown is being compiled to an html file, the default graphics device used by code chunks embedded in the markdown is ` png() `. This device creates a lossless portable graphics format file that can be embedded in the html and later displayed by a web browser application when viewing the file. The graphics device is open by default, so code in an Rmarkdown chunk does not directly open the device. Chunk options can be changed to allow graphics device arguments to be altered from their default values. For example, the code chunk generated the test graph below sets new values for three chunk options that result in a customized canvas for the associated graphics device. Code chunk options are set by including a list of key-value pairs after the r in the curly brackets specifying the beginning of the chunk.

```
 {r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}
```

Description of Rmarkdown chunk options being used for the first time:

- ` fig.width `: Width of the canvas where graphical elements can be added
    - ` 6 `: Width of the canvas will be 6 inches
- ` fig.height `: Height of the canvas where graphical elements can be added
    - ` 5 `: Width of the canvas will be 6 inches
- ` dev.args `: List of arguments to be passed to the device
    - ` 12 `: Renderer will use a 12 point font for characters (12/72 = 1/6 of an inch)
    
The following code chunk provides a simple example of how using these chunk options specifies the properties of the canvas created by the default ` png() ` device used by Rmarkdown.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Plot points at coordinates 0, 0 and 1, 1
plot(
  x = c(0, 1),
  xlab = "x",
  y = c(0, 1),
  ylab = "y"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

Description of functions and arguments being used for the first time:

- ` box() `: Draws a box around predefined regions of a graphing canvas
    - ` which `: Specifies which region of the graphing canvas around which to draw the box
        - ` "outer" `: Results in a box around the outer edge of the canvas


**Note to RStudio users:** The device used by RStudio to show graphics within the coding window is not the same device used to generate the compiled document. Be sure to view figures in the final compilation to be sure they have the desired characteristics, and do not assume the test figures in the coding window will necessarily match the final figure.


## `r sec1`.`r sec2 <- sec2 + 1; sec2`. Other useful devices

Other useful graphics devices will render to a new pop-up window on your computer. Because these windows are operating system dependent, a different device is needed for Windows or Mac computers. The ` windows() ` function will open a pop-up graphics device on a PC, and the ` quartz() ` function will open a pop-up graphics device on a Mac. Use the following code as a basis for experimentation. Note that you should not call ` dev.off() ` after opening these devices or the pop-up will close before you get a chance to look at it. Also note that ` graphics.off() ` will close any lingering devices, including previously opened pop-up windows. 

For a PC:

``` 
# Shut down any existing devices
graphics.off()

# Open the windows graphics device 
windows(
  width = 6,
  height = 5,
  pointsize = 12
)

# Plot points at coordinates 0, 0 and 1, 1
plot(
  x = c(0, 1),
  xlab = "x",
  y = c(0, 1),
  ylab = "y"
)
```

For a Mac:

``` 
# Shut down any existing devices
graphics.off()

# Open the quartz graphics device 
quartz(
  width = 6,
  height = 5,
  pointsize = 12
)

# Plot points at coordinates 0, 0 and 1, 1
plot(
  x = c(0, 1),
  xlab = "x",
  y = c(0, 1),
  ylab = "y"
)
```

Description of functions and arguments being used for the first time:

- ` windows() ` for a PC or ` quartz() ` for a Mac: Opens a graphics device that writes to a pop-up window in the Windows operating system
    - ` width `: Width of the canvas where graphical elements can be added
        - ` 6 `: Width of the canvas will be 6 inches
    - ` height `: Height of the canvas where graphical elements can be added
        - ` 5 `: Height of the canvas will b 5 inches
    - ` pointsize `: The default point size of characters and symbols
        - ` 12 `: Renderer will use a 12 point font for characters (12/72 = 1/6 of an inch) 

Finally, Windows users may want to experiment with the ` win.metafile() ` graphics device if you would like to render to the clipboard in a form that can be directly pasted into a Microsoft Word document or a Microsoft Powerpoint slide. Devices like ` bmp() `, ` jpeg() `, ` png() `, and ` tiff() ` are available to render graphics into various common raster image files. These files tend to take up more space (depending on image quality), but are also more reliably transferable across operating systems.


# `r sec1 <- sec1 + 1; sec2 <- 0; sec1`. Dissecting the ` plot() ` function

Taking full control over your figures requires a deeper understanding of what is happening when high-level functions like ` plot() ` are used. This understanding specifically requires knowing how S3 objects work in R, and why ` plot.default() ` is actually the function that gets called when you call ` plot() ` on a numeric vector. It also requires understanding how the device canvas is scaled and how individual graphical elements are added to the canvas by lower level graphing functions. The following steps through these functions in the same order they are called by ` plot.default() `.


## `r sec1`.`r sec2 <- sec2 + 1; sec2`. Why is ` plot.default() ` called when I call ` plot() `?

One way to explore the S3 abstraction for ` plot() ` is to look at the implementation of the function. For functions implemented with R code, the implementation of the function can be viewed by typing the function name at the console prompt, without parentheses.

``` {r}

plot

```

The entire implementation of this function is simply a call to the ` UseMethod() ` function, which means that the function that ultimately gets called depends on the data type of the first argument to the ` plot(x, y, ...) ` function. In other words, a call to `plot` is not enough information to know what is going to happen, you also need to know the data type of the first argument to ` plot(x, y, ...) `. This abstraction is an artifact of the S3 implementation of object oriented programming, and is the reason why calling ` help("plot", package = "base") ` yields so little specific information about the arguments that can be used with ` plot() `. The remaining arguments that can be used depend on the data type of the first argument. 

Throughout these exercises, the first argument (` x `) to ` plot(x, y, ...) ` will always be an atomic vector, which results in the ` plot.default() ` function being called by ` UseMethod() ` after ` plot() ` is called in a script. Note that the implementation of ` plot.default() ` contains far more complex code that actually creates a figure. For further exploration, note that calling ` help("plot.default") ` also yields far more detailed information about how to use the ` plot() ` function on vector arguments than ` help("plot", package = "base") `. 

``` {r}

plot.default

```

For other examples of S3 functional abstractions, look at the implementation of the ` print() ` or ` summary() ` functions. See if you can find the specific implementations of these functions for particular data types that might be passed as the first argument to the abstraction (e.g., ` print.default() ` or ` print.data.frame() `) . While detailed knowledge of the benefits of these object oriented principles of polymorphism is not strictly necessary to use R, deeper understanding of this topic will allow for more informed troubleshooting when a function does something unexpected. If nothing else, deeper understanding of S3 abstractions will provide a pathway to finding more detailed ` help() ` documentation on the functions you are actually using when calling abstract methods.


## `r sec1`.`r sec2 <- sec2 + 1; sec2`. Scaling the canvas

Placing graphics on the canvas at a desired locations first requires definition of the scales for the axes of the canvas. Much of the first part of the ` plot.default() ` function is aliasing and bookkeeping that are a topic for different discussion. The lines of code that actually start to build the plot are

```
plot.new()
localWindow(xlim, ylim, log, asp, ...)
```

Earlier in the function, ` localWindow() ` is established as a wrapper around the function ` plot.window() ` with the line

```
localWindow <- function(..., col, bg, pch, cex, lty, lwd) plot.window(...)
```

which means that calls to ` localWindow() ` are ultimately resulting in calls to ` plot.window() `. This pattern is applied to many graphical functions being used to simplify the large number of arguments that need to be passed explicitly to those functions, but understanding the details of this practice is not necessary at this time.

The function ` plot.new() ` prepares the canvas for a new plot, and the function ` plot.window() ` scales the axes of the prepared canvas to establish the coordinate system for the canvas. Scaling of the canvas is based on vectors passed to ` xlim ` and ` ylim ` arguments that define the coordinates associated with the boundaries of a rectangular plot region on the canvas (i.e. the area of the canvas where data is intended to be plotted). The effect of these functions can be explored by calling them directly with simplified arguments, consistent with examples provided above. Here, a box is drawn around the plot region and the outer edge of the canvas to aid with visualization of the basis for the coordinate system, though symbolism is not yet provided for visualization of the coordinate system numerics (see later materials on the ` Axis() ` function). The size of the margins around the plot region are defined by default graphic parameters that will be discussed in detail, later (e.g., see later materials introducing ` par("mar") `). As above, the Rmarkdown code chunk options are set to control the dimensions of the canvas being embedded in the compiled document, and all code chunks in the remainder of this section are configured the same way.

```
 {r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}
```

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Prepare the canvas for a new plot
plot.new()

# Scale the canvas 
plot.window(
  xlim = c(0, 1),
  ylim = c(0, 1)
)

# Draw a box around the plot region and around the outer edge of the canvas
box()
box(which = "outer")

```

Description of functions and arguments being used for the first time:

- ` plot.new() `: Prepares the device canvas for a new plot
- ` plot.window() `: Scales the canvas, providing an orthogonal 2-dimensional coordinate system (x is horizontal and y is vertical) for locating graphical objects placed on the canvas by later calls to graphing functions.
    - ` xlim `: Numerical vector with 2 elements specifying the leftmost and rightmost values to be used in the graphing area of the coordinate system
    - ` ylim `: Numerical vector with 2 elements specifying the bottommost and topmost values to be used in the graphing area of the coordinate system
- ` box() `: Draws a box around predefined regions of a graphing canvas
    - No arguments implies the default ` which = "plot" `, which results in a box drawn around the plot region.

The results are not particularly exciting. The fact that we have established a coordinate system does not result in any graphical elements being added to the canvas. The boxes aiding in visualization had to be added manually. However, this code has provided a spatially rectified blank slate, such that there is now a context for adding graphical elements at the exact coordinates desired.


## `r sec1`.`r sec2 <- sec2 + 1; sec2`. Plotting the data

Graphics objects can now be added to the canvas in layers. Lower layers will still be visible, unless opaque elements are added on top of them. The ` plot.default() ` function plots the data as the first visible element of the figure, using the function ` plot.xy() `. The first argument (` xy `) is expected to be a list of vectors characterizing the coordinates to be plotted. This list can be conveniently constructed using the ` xy.coords() ` function with arguments specifying the x and y coordinates for a number of points to be plotted. The points plotted here are at coordinates 0, 0 and 1, 1. Multiple arguments are available to adjust the symbolism of each data point, but symbols will be black open circles if those arguments are not specified.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Prepare the canvas for a new plot
plot.new()

# Scale the canvas 
plot.window(
  xlim = c(0, 1),
  ylim = c(0, 1)
)

# Draw a box around the plot region and around the outer edge of the canvas
box()
box(which = "outer")

# Plot example data points
plot.xy(
  xy = xy.coords(
    x = c(0, 1),
    y = c(0, 1)
  ),
  type = "p"
)

```

Description of functions and arguments being used for the first time:

- ` plot.xy() `: Renders the symbolism of a bivariate scatter plot on the canvas
    - ` xy `: An coordinate list specifying information about the x an y coordinates of a set of data to be plotted.
        - ` xy.coords(...) `: A function returning the list of x and y coordinates for the data set to be plotted (see below)
    - ` type `: The character string code for the type of scatter plot to render
        - ` "p" `: Results in data being plotted as point symbols in the scatter plot
- ` xy.coords() `: Creates a coordinate list for a bivariate data set to be plotted
    - ` x `: Numerical vector of values for the x coordinate of each data point graphed
        - ` c(0, 1) `: Two data points with x coordinates of 0 and 1, respectively.
    - ` y `: Numerical vector of values for the y coordinate of each data point graphed
        - ` c(0, 1) `: Two data points with y coordinates of 0 and 1, respectively.

The result is two points on the graph, exactly as would be expected by two points plotted within the domain defined in ` plot.window() `. The box around the plot region provides a hint of the layout of the coordinate system in relation to the plotted values at x = 0, y = 0 and x = 1, y = 1, but further numeric symbolism around the plot region is required to directly read values from the graph.


## `r sec1`.`r sec2 <- sec2 + 1; sec2`. Creating the axes

The ` Axis() ` function provides a tool for adding axes describing the scale of the canvas in the area where the data are being plotted. This function is highly configurable to make an axis with ticks and labels exactly where desired, but the default arguments will attempt to create ticks and labels that are reasonably legible. Here, the only argument provided is the side of the graph where the axis should be located (1 is the bottom and 2 is the left). Note that the box around the plot region has been ommited to provide a clear view of the symbolism generated by the ` Axis() ` function.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Prepare the canvas for a new plot
plot.new()

# Scale the canvas 
plot.window(
  xlim = c(0, 1),
  ylim = c(0, 1)
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

# Plot example data points
plot.xy(
  xy = xy.coords(
    x = c(0, 1),
    y = c(0, 1)
  ),
  type = "p"
)

# Add an x axis
Axis(side = 1)

# Add a y axis
Axis(side = 2)

```

Description of functions and arguments being used for the first time:

- ` Axis() `: Renders the symbolism of an axis with labeled ticks
    - ` side `: An integer specifying the side of the plotting area upon which to place the axis (1 = bottom, 2 = left, 3 = top, 4 = right)
        - ` 1 ` or ` 2 `: Call with 1 creates the x axis and call with 2 creates the y axis

The axes clearly label the scaling of the canvas in the plot region, where an automated algorithm has determined aesthetically pleasing tick intervals and tick labels. The consistency of the scaling established by ` plot.window() ` is now evident, in that the data points plotted earlier line up with the appropriate ticks on the axes. These are the fundamentals of building any graph on the canvas.


## `r sec1`.`r sec2 <- sec2 + 1; sec2`. Labeling the axes

The ` title() ` function is a unified tool for labeling different parts of the graph. Most style guides for figures suggest that the area where data are plotted should be differentiated from the rest of the figure. The ` box() ` function with no arguments is reintroduced here to clearly delineate the plot region from the rest of the canvas. The box overlaps with the axes lines, such that the axes are effectively only providing the ticks and tick labels. As with previous graphics tools, the location and symbolism used for the elements being added are highly configurable with additional arguments. However, the default arguments are used for now, and detail on arguments that are commonly altered from the defaults are discussed later.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Prepare the canvas for a new plot
plot.new()

# Scale the canvas 
plot.window(
  xlim = c(0, 1),
  ylim = c(0, 1)
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

# Plot example data points
plot.xy(
  xy = xy.coords(
    x = c(0, 1),
    y = c(0, 1)
  ),
  type = "p"
)

# Add an x axis
Axis(side = 1)

# Add a y axis
Axis(side = 2)

# Add a box around the area where data is plotted
box()

# Add axis labels
title(
  xlab = "x",
  ylab = "y"
)

```

Description of functions and arguments being used for the first time:

- ` title() `: Renders the symbolism of labels on various elements of a graphing canvas
    - ` xlab `: A character string (or expression) specifying the label for the x axis
        - ` "x" `: Results in the x axis being labeled with an "x"
    - ` ylab `: A character string (or expression) specifying the label for the y axis
        - ` "y" `: Results in the y axis being labeled with a "y"


## `r sec1`.`r sec2 <- sec2 + 1; sec2`. Summary

This dissection of `plot.default() ` clearly requires substantially more lines of code than the original example of a single call to ` plot() ` that generates exactly the same figure. The point here is not that you should avoid using ` plot() ` and subsequently ` plot.default() `, because it clearly provides substantial convenience for basic plotting. The point is that your ability to debug and be creative with graphing code will expand if you understand how functions like ` plot.default() ` construct a graph, such that you can take advantage of the power of altering the arguments for each component of the graph should it be necessary to do something ` plot.default() ` does not allow. Furthermore, understanding of these details allows for much more informed troubleshooting should high level functions like ` plot.default() ` produce something unexpected in a given application.


# `r sec1 <- sec1 + 1; sec2 <- 0; sec1`. Taking full control of base R graphics

A revisit of the code and result for the basic figure introduced earlier reveals that the ` plot() ` function must be making several assumptions about the desired format of the plot. 

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Plot points at x, y coordinates 0, 0 and 1, 1
plot(
  x = c(0, 1),
  xlab = "x",
  y = c(0, 1),
  ylab = "y"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

Note that many aesthetic or technical aspects of this plot did not have to be defined in the code, including (but not limited to): the use of point symbols rather than lines; the shape and color of the points; the thickness of boxes and axes lines; and the location of the axes relative to the edges of the canvas. However, computers are generally not able to guess at what these aspects of plots should look like, so default information about the aesthetic or technical appearance of graphs must exist somewhere in the underlying R data structures. An important trick to full control over figures is to understand where that information is stored, how it is used, and how to change it.

A common location for default graphical information is the definition of default values for the arguments to graphical functions. For example, the ` plot.default() `function (e.g., what is called if using ` plot() ` on vectors) accepts the optional argument ` type ` that controls the type of symbolism used for the data in the graph. The values that can be passed to ` type ` to control the symbolism are documented in the package containing the function and in this case can be accessed using the  ` help("plot.default") `. The potential values for arguments are usually described in either the **Arguments** section or **Details** section of the function documentation. Any default value defined for a parameter is usually described in the **Usage** or **Arguments** section. A quick and succinct way to view the definition of a function's arguments is to use the ` args() ` function (e.g., ` args(plot.default) `).

```{r}
# Display the definition of arguments for the function plot.default
args(name = plot.default)
```

Description of functions and arguments being used for the first time:

- ` args() `: Returns the argument definitions for a function. Return type is a function with the argument definition but a NULL code block.
    - ` name `: The name of the function for which the argument definition is retrieved
        - ` plot.default `: Causes the function to return the argument definitions for the function ` plot.default() `

Note that the argument ` type ` is followed by the assignment ` = "p" `, which designates that it will take on the value of the character string ` "p" ` if a value for that argument is not provided in a given call to the function. Any differing value provided for ` type ` in a call to the function will replace the default value and thus change the symbolism in the plot. For example, passing the value ` "o" ` to the argument ` type ` will result in an overlay of both points and lines.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Plot points at coordinates 0, 0 and 1, 1
plot(
  x = c(0, 1),
  xlab = "x",
  y = c(0, 1),
  ylab = "y",
  type = "o"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

Description of functions and arguments being used for the first time:

- ` plot() ` or ` plot.default() `: A high level function for creating a new plot with a single line of code
    - ` type ` : A character string that defines the symbolism used when plotting data. For example, a value of "p" denotes points, "l" denotes lines, and "o" denotes an overlay of points and lines (among others). Note that the argument ` type ` is passed to plot generically here and ultimately this argument is not used specifically until it is passed to the ` plot.xy() ` function by ` plot.default() `.
        - ` "o" `: Results in graphing data as an overlay of points and lines

Extensive information used to plot graphical elements is also stored in a collection of default values for common graphical parameters associated with the open device. The current default values for these graphical parameters can be accessed by passing the names of those parameters as arguments to the ` par() ` function. For example, the graphics parameter that determines the symbols used for data points is ` pch `, so the current value of "pch" can viewed with...

```{r}
# Display the value of the graphical parameter pch for the current graphics device
par("pch")
```

Description of functions and arguments being used for the first time:

- ` par() `: Allows the values of graphical parameters associated with the current open graphics device to be retrieved or altered. Calling ` par() ` with no arguments will provide the full list of available graphics parameters.
    - ` ... `: The ellipses in the definition of arguments to a function indicate that the function will accept any number of generic arguments when called. "Generic" means that the function will either interpret the comma-delimited generic collection of elements without explicit definition of argument names, or it means that any generic arguments provided will be passed generically to other functions called when the function's code is executed. Use of ellipses in graphical functions is a very common practice for passing values for graphical parameters generically from higher level functions to lower level functions.
        - ` "pch" `: Passing the character string "pch" as a generic argument to ` par() ` results in a return value of the current default value of the correspondingly named graphical parameter. Note that multiple parameter names can be provided in a comma delimited list of character strings, which will return a named list of values with each element providing the current default value for each graphical parameter provided. For example ` par("pch", "lty") ` will return the current default values for the point type and line type graphical parameters.

By default, ` pch ` typically has a value of 1, which specifies an open circle, hence the symbols plotted in the graphs so far have all been open circles. The par function can also be used to change the values of graphical parameters based on a collection of ` <parameter> = <value> `  in the argument to the function call. Thus, the default symbol can be changed to an open triangle by changing the value of the graphics parameter ` pch ` to 2.

```{r}
# Change the value of the graphical parameter pch for the current graphics device
par(pch = 2)

# Display the value of the graphical parameter pch for the current graphics device
par("pch")
```

Description of functions and arguments being used for the first time:

- ` par() `: Allows the values of graphical parameters associated with the current open graphics device to be retrieved or altered.
    - ` pch = 2 `: Passing a named value to the generic arguments in ` par() ` will result in the default value for the named graphical parameter to be changed to the provided value. Setting the graphical parameter ` pch ` to 2 will result in data being represented by open triangles.

Changing the value of a graphical parameter with ` par() ` will change the default value within the open graphics device for all subsequent calls to graphical functions, until the device is closed or reset. If we add an additional plot to the basic graph, it will also use the new setting of the graphical parameter ` pch `.

The effect of this change can be demonstrated by calling two different graphing functions that plot data points in sequence. The understanding gained from dissecting the ` plot() ` function provides one method for adding an additional plot to the same basic graph, putting points in the unused corners of the basic graph using the ` plot.xy() ` function.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Change the value of the graphical parameter pch for the current graphics device
par(pch = 2)

# Plot points at coordinates 0, 0 and 1, 1
plot(
  x = c(0, 1),
  xlab = "x",
  y = c(0, 1),
  ylab = "y",
  type = "o"
)

# Plot example data points
plot.xy(
  xy = xy.coords(
    x = c(0, 1),
    y = c(1, 0)
  ),
  type = "p"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

All the data points are open triangles, demonstrating how changing the ` pch ` graphical parameter with ` par() ` altered the value for all subsequent calls to graphics functions within the code chunk. Note that in Rmarkdown, each code chunk will open a separate graphics device, such that any changes to graphics parameters applied to the device in one code chunk will not propagate to other code chunks without further action.

The main reason that graphics parameters controlled by ` par() ` have influence with subsequent graphing code is that they often represent the default values for arguments to lower level graphing functions. Therefore, the default values of the graphics parameters can often be locally overridden using values passed directly to those arguments. For example, consider the default value for the ` pch ` parameter in the list of arguments to the ` plot.xy() ` function.

```{r}
args(plot.xy)
```

The default value for the ` pch ` argument comes directly from the graphical parameters via a call to ` par("pch") `. Therefore, the value for the graphing parameter that would normally result in triangle symbols from the previous example can be overridden for the call to ` plot.xy() ` by directly setting a value for the ` pch ` argument.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Change the value of the graphical parameter pch for the current graphics device
par(pch = 2)

# Plot points at coordinates 0, 0 and 1, 1
plot(
  x = c(0, 1),
  xlab = "x",
  y = c(0, 1),
  ylab = "y",
  type = "o"
)

# Plot example data points
plot.xy(
  xy = xy.coords(
    x = c(0, 1),
    y = c(1, 0)
  ),
  type = "p",
  pch = 0
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

Description of functions and arguments being used for the first time:

- ` plot.xy() `: Renders the symbolism of a bivariate scatter plot on the canvas
    - ` pch `: A vector of integers specifying the symbol to use for data points.
        - ` 0 `: A value of zero specifies an open square symbol
        
In this case, the value of the graphical parameter ` pch ` is ignored in place of the value directly passed to the ` pch ` argument of the ` plot.xy() ` function, hence the squares in the second plot rather than the triangles.

The remainder of this section provides tutorials on adjusting the values passed to arguments of graphical functions or the default values of graphics parameters used by those functions, which together provide a great deal of explicit control over the scaling, formatting, symbolism, and labeling used in base R graphics. Throughout the remainder of this section, frequent reference to the base R documentation using ` help("par") ` or the help for lower level graphing functions is suggested to convince yourself you understand the consequences of changing the default value for each graphics parameter before calling graphical functions. As always, experimentation is also highly encouraged.


## `r sec1`.`r sec2 <- sec2 + 1; sec3 <- 0; sec2`. Taking full control of scaling a single graph

In base R, the scaling of the coordinate system for a device canvas is defined in the context of a rectangular subset of the canvas designated as a *plot region*. This region defines the area within which symbols representing data are conventionally rendered, though the scale extends across the entirety of the canvas and symbols can technically be plotted anywhere, if desired. The scaling function ` plot.window() ` is responsible for establishing the coordinate system to be used by later calls to graphics functions. Derivation of the coordinate system is based on the margins between the plot region and the edge of the canvas, the limits of the x and y coordinates that define the edges of the plot region, and parameters that control buffering of the symbols within the plot regions from the edges of the plot region. Therefore, taking full control of scaling requires understanding the graphical parameters and function arguments that control the behavior of ` plot.window() ` in performing these derivations.


### `r sec1`.`r sec2`.`r sec3 <- sec3 + 1; sec3` Defining inner margins

Two sets of nested margins and a multi-panel configuration tool together define the overall margins for any given plot region from the edges of the canvas. Outer margins designed for controlling the white space between the edges of a multi-panel plot and the edges of the canvas. Inner margins control the white space between an individual plot region and the edges of its panel. Examples in this section will focus on a single graph, where the outer margins will be set to zero and the inner margins have sole control over the white space between the single plot region and the edges of the canvas. See ` help("par") ` and the documentation for graphical parameters ` oma ` / ` omi ` and ` mar ` / ` mai ` for visualizations of the margin structure.

Default graphics parameters are typically initially configured for single graphs (not multi-panel graphs), so the outer margins are typically set to zero by default. Depending on units used, the outer margins can be retreived or set with the graphical parameters ` oma ` or ` omi `.

```{r}
# Retrieve values of the oma and omi graphics parameters
par("oma", "omi")
```

Description of functions and arguments being used for the first time:

- ` par() `: Allows the values of graphical parameters associated with the current open graphics device to be retrieved or altered.
    - ` "oma" ` or ` "omi" `: Returns the current setting for the graphical parameter defining the outer margins. The return value will be a vector with 4 elements designating the bottom, left, top, and right margins, in that order.

Multi-panel plots will be covered in more detail later, so we will not experiment with outer margins here. Just note for now that the default values are typically zero and have no effect on scaling when set to zero. In this case, the space available between the plot region and the edge of the canvas will be defined entirely by graphics parameters controlling the inner margins.

With outer margins defaulting to zero and working with a single graph, the scaling for the basic plots we have examined so far has been determined by the default values for the margins for individual plots within their panels.

```{r}
# Retrieve values of the mar and mai graphics parameters
par("mar", "mai")
```

Description of functions and arguments being used for the first time:

- ` par() `: Allows the values of graphical parameters associated with the current open graphics device to be retrieved or altered.
    - ` "mar" ` or ` "mai" `: Returns the current setting for the graphical parameter defining the default margins for an individual graph. The return value will be a vector with 4 elements designating the bottom, left, top, and right margins, in that order. The parameter ` mar ` is in the relative units of *lines*, which are sized relative to the point size of the font being used in labels in the margin of the graph.  The parameter ` mai ` is in absolute units of inches, which is independent of font size. If either of these parameter values is changed using the ` par() ` function, the other is automatically updated based on the font size being used.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Plot points at coordinates 0, 0 and 1, 1
plot(
  x = c(0, 1),
  xlab = "x",
  y = c(0, 1),
  ylab = "y"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

The extra white space visible at the top and right of this basic plot is thus determined by the default values for the third and fourth elements of ` mar ` or ` mai `. Full control and consistency of the margins and subsequent scaling of the canvas can be gained by setting these graphical parameters explicitly with ` par() ` before using the graphical functions that reference them. For example, we can reduce the extra white space at the top and right sides of the graph by reducing the sizes of the margin defined in the third and fourth elements of ` mai `.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Define margins leaving room for axes on the bottom and left sides
par(
  omi = c(0, 0, 0, 0),
  mai = c(0.9, 0.9, 0.2, 0.2)
)

# Plot points at coordinates 0, 0 and 1, 1
plot(
  x = c(0, 1),
  xlab = "x",
  y = c(0, 1),
  ylab = "y"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

Experiment with values for the margins to be sure you understand their behavior. For example, recognize the potentially confusing behavior that labels might be cut off if the scaling dictates they fall outside the canvas. Understanding behavior of margins will prevent going down the incorrect troubleshooting path of assuming the axis labels are not being generated in the following graph. They are being generated, just outside the canvas that is in view.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Define margins without leaving room for axes labels on the
# bottom and left sides
par(
  omi = c(0, 0, 0, 0),
  mai = c(0.6, 0.6, 0.2, 0.2)
)

# Plot points at coordinates 0, 0 and 1, 1
plot(
  x = c(0, 1),
  xlab = "x",
  y = c(0, 1),
  ylab = "y"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

Not that R graphics will not warn you that components of your graph are not visible because they are being plotted outside the limits of the device canvas.


### `r sec1`.`r sec2`.`r sec3 <- sec3 + 1; sec3` Defining the limits of the plot region

Once margins are established, the derivation of the coordinate system for the canvas is subsequently controlled by the limits of the plot regions established by the ` xlim ` and ` ylim ` arguments to ` plot.window() `. Unless otherwise specified, the values of ` xlim ` and ` ylim ` will be determined by the associated minimum and maximum values in the vectors begin plotted. This default behavior will be overridden if explicit values for ` xlim ` and ` ylim ` are somehow passed to ` plot.window() ` when scaling the canvas. For example, passing ` xlim ` and ` ylim ` values to the generic ` plot() ` function will result in these values being passed to ` plot.window() ` via a call to ` plot.default() `.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Define margins leaving room for axes on the bottom and left sides
par(
  omi = c(0, 0, 0, 0),
  mai = c(0.9, 0.9, 0.2, 0.2)
)

# Plot points at coordinates 0, 0 and 1, 1
plot(
  x = c(0, 1),
  xlim = c(-1, 2),
  xlab = "x",
  y = c(0, 1),
  ylim = c(-1, 2),
  ylab = "y"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

Description of functions and arguments being used for the first time:

- ` plot() ` or ` plot.default() ` : A high level function for creating a new plot with a single line of code. The function ` plot() ` is an S3 abstraction, which in this case results in a call to ` plot.default() `.
    - ` xlim `: Numerical vector with 2 elements specifying the leftmost and rightmost values to be used in the graphing area of the coordinate system
    - ` ylim `: Numerical vector with 2 elements specifying the bottommost and topmost values to be used in the graphing area of the coordinate system

Or the effect of changing these arguments on scaling the canvas can be demonstrated by altering the call to ` plot.window() ` directly.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Define margins leaving room for axes on the bottom and left sides
par(
  omi = c(0, 0, 0, 0),
  mai = c(0.9, 0.9, 0.2, 0.2)
)

# Prepare the canvas for a new plot
plot.new()

# Scale the canvas 
plot.window(
  xlim = c(-1, 2),
  ylim = c(-1, 2)
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

# Plot example data points
plot.xy(
  xy = xy.coords(
    x = c(0, 1),
    y = c(0, 1)
  ),
  type = "p"
)

# Add an x axis
Axis(side = 1)

# Add a y axis
Axis(side = 2)

# Add a box around the area where data is plotted
box()

# Add axis labels
title(
  xlab = "x",
  ylab = "y"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

Note that order of the magnitude of the limits in either the x or y direction is arbitrary. The example above follows the common convention that values increase in magnitude with movement upward in y space and that values increase in magnitude with movement to the right in x space. Reversing this convention in derived the coordinate system simply requires reversing the definition of the values of the limits associated with the bounds of the plot region. For example, the following will invert the y axis from previous examples by setting the y value associated with the bottom of the plot region to 1 and the y value associated with the top of the plot region to 0.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Define margins leaving room for axes on the
# bottom and left sides
par(
  omi = c(0, 0, 0, 0),
  mai = c(0.9, 0.9, 0.2, 0.2)
)

# Plot points at coordinates 0, 0 and 1, 1
plot(
  x = c(0, 1),
  xlab = "x",
  y = c(0, 1),
  ylim = c(1, 0),
  ylab = "y"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

The numerical distribution used to represent the coordinate system for either axis can also be altered to a base-10 logarithmic scale. A logarithmic number system can be specified by a passing a value for the ` log ` argument generically to ` plot() ` or directly to ` plot.window() ` where the argument ultimately takes effect. The value for this argument can be the character string "x" or "y" to specify a log scale on only one of the axes, or the character string "xy" to specify a log scale on both axes. For example, the x scaling can be altered to be on a log scale with x coordinate values at 0.1 and 1 as follows (values of zero cannot be plotted in log space).

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Define margins leaving room for axes on the
# bottom and left sides
par(
  omi = c(0, 0, 0, 0),
  mai = c(0.9, 0.9, 0.2, 0.2)
)

# Plot points at coordinates 0, 0 and 1, 1
plot(
  x = c(0.1, 1),
  xlab = "x",
  y = c(0, 1),
  ylab = "y",
  log = "x"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

Description of functions and arguments being used for the first time:

- ` plot() ` or ` plot.default() `: A high level function for creating a new plot with a single line of code. The function ` plot() ` is an S3 abstraction, which in this case results in a call to ` plot.default() `.
    - ` log `: A character string specifying which axes should be in log space. The value "x" or "y" specifies one of the axes is in log space, and the value of "xy" specifies that both axes are in log space. Note that this argument is passed to ` plot() ` generically, and its effect on scaling is not realized until ` plot.default() ` ultimately passes the value assigned to ` log ` on to ` plot.window() `.
        - ` "x" `: Specifies that the x axis should be scaled in log space


### `r sec1`.`r sec2`.`r sec3 <- sec3 + 1; sec3` Buffers within the plot region

In the basic plot used as a frequent example, note the extra internal space between the edges of the plot region and the minima of 0 and the maxima of 1 defining the default limits of the plot region. 



This default buffering (which is derived from 4% of the difference between the maximum and minimum of the limits) influenced the overall scaling of the canvas and is controlled by the axis type. The axis types are configurable with the ` xaxs ` and ` yaxs ` graphics parameters.

```{r}
# Retrieve the values of the xaxs and yaxs 
# graphics parameters
par("xaxs", "yaxs")
```

Description of functions and arguments being used for the first time:

- ` par() `: Allows the values of graphical parameters associated with the current open graphics device to be retrieved or altered.
    - ` "xaxs" ` or ` "yaxs" `: Returns the current setting for the graphical parameter defining the type of the x or y axes. By default, values are the character string "r" indicated a "regular" scaling (includes a 4% buffer around the limits of the plot region).

The default types for the axes can be specified generally for the device using the ` par() ` function.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Define margins leaving room for axes on the
# bottom and left sides
# Set the types of both axes to internal
par(
  omi = c(0, 0, 0, 0),
  mai = c(0.9, 0.9, 0.2, 0.2),
  xaxs = "i",
  yaxs = "i"
)

# Plot points at coordinates 0, 0 and 1, 1
plot(
  x = c(0, 1),
  xlab = "x",
  y = c(0, 1),
  ylab = "y"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

Values for the ` xaxs` and ` yaxs ` arguments can also be passed generically to the ` plot() ` function, which will ultimately pass them on to ` plot.window() ` to achieve the same result. However, this technique will not change the default graphical parameter values, so the effects of using these arguments would not propagate to other graphs created later on the same device.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Define margins leaving room for axes on the
# bottom and left sides
par(
  omi = c(0, 0, 0, 0),
  mai = c(0.9, 0.9, 0.2, 0.2)
)

# Plot points at coordinates 0, 0 and 1, 1
plot(
  x = c(0, 1),
  xlab = "x",
  xaxs = "i",
  y = c(0, 1),
  ylab = "y",
  yaxs = "i"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

Note that without the buffering, the symbols on this graph are barely visible. Only a quarter of each circle symbol can be seen in the corners of the plot region. The full circles are actually there, the parts of them outside the plot region are just being clipped. This clipping is, yet again, controlled by a graphics parameter (i.e., ` xpd `).

```{r}
# Retrieve the value of the xpd graphics parameter
par("xpd")
```

Description of functions and arguments being used for the first time:

- ` par() `: Allows the values of graphical parameters associated with the current open graphics device to be retrieved or altered.
    - ` "xpd" `: Returns the current setting for the logical control on whether plot region symbols are rendered when located in the margins. A value of "TRUE" means that symbols in the margins will be visible. A value of "FALSE" means they will not.

This graphics parameter can be altered to allow plot region symbols to be visible if plotted in the margins.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Define margins leaving room for axes on the
# bottom and left sides
# Allow rendering of plot region symbolism
# in the margins
par(
  omi = c(0, 0, 0, 0),
  mai = c(0.9, 0.9, 0.2, 0.2),
  xpd = TRUE
)

# Plot points at coordinates 0, 0 and 1, 1
plot(
  x = c(0, 1),
  xlab = "x",
  xaxs = "i",
  y = c(0, 1),
  ylab = "y",
  yaxs = "i"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

As with axis types, a value for the ` xpd ` argument can be generically provided to ` plot() `. This generic argument is subsequently passed to ` plot.xy() `, which has the effect of disabling clipping for the generated plot. However, this does not change the default graphics parameter, so this approach would have no effect on future plotting on the same device.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Define margins leaving room for axes on the
# bottom and left sides
par(
  omi = c(0, 0, 0, 0),
  mai = c(0.9, 0.9, 0.2, 0.2)
)

# Plot points at coordinates 0, 0 and 1, 1
plot(
  x = c(0, 1),
  xlab = "x",
  xaxs = "i",
  y = c(0, 1),
  ylab = "y",
  yaxs = "i",
  xpd = TRUE
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

While locating the symbols representing data outside the plot region is not typical, this exercise illustrates the effect of the ` xpd ` graphical parameter or argument, which is useful in common labeling tasks like placing legends outside the axes of plots.


### `r sec1`.`r sec2`.`r sec3 <- sec3 + 1; sec3` Summary

So far, we have been able to gain complete control of scaling while continuing to use the high-level abstract function ` plot() `, which ultimately calls ` plot.default() ` and passes generic arguments on to lower level graphing functions, such as ` plot.window() ` and ` plot.xy() `. Understanding the behavior of these examples comes from recognizing that the resulting plot is being generated by the following sequence of calls to lower level graphical functions. For example, the graph with a logarithmic x axis, with altered margins, without buffers, and with visible symbols in the margins can be properly scaled and created with lower level functions as follows.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Define margins leaving room for axes on the
# bottom and left sides
par(
  omi = c(0, 0, 0, 0),
  mai = c(0.9, 0.9, 0.2, 0.2)
)

# Prepare the canvas for a new plot
plot.new()

# Scale the canvas 
plot.window(
  xlim = c(0.1, 1),
  xaxs = "i",
  ylim = c(0, 1),
  yaxs = "i",
  log = "x"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

# Plot example data points
plot.xy(
  xy = xy.coords(
    x = c(0.1, 1),
    y = c(0, 1)
  ),
  type = "p",
  xpd = TRUE
)

# Add an x axis
Axis(side = 1)

# Add a y axis
Axis(side = 2)

# Add a box around the area where data is plotted
box()

# Add axis labels
title(
  xlab = "x",
  ylab = "y"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

Description of functions and arguments being used for the first time:

- ` plot.window() `: Scales the canvas, providing an orthogonal 2-dimensional coordinate system (x is horizontal and y is vertical) for locating graphical objects placed on the canvas by later calls to graphing functions.
    - ` xaxs ` or ` yaxs `: Character string specifying the type of scaling to use for the x or y axis
        - ` "i" `: An "internal" axis does not include any buffering outside the minima and maxima of the values in the x and y vectors of coordinates
    - ` log `: A character string specifying which axes should be in log space. The value "x" or "y" specifies one of the axes is in log space, and the value of "xy" specifies that both axes are in log space.
        - ` "x" `: Specifies that the x axis should be scaled in log space
- ` plot.xy() `: Renders the symbolism of a bivariate scatter plot on the canvas
    - ` xpd `: A logical value indicating whether plot region symbolism located at canvas coordinates in the margins outside the plot region should be visible (` TRUE `) or clipped (` FALSE `)
        - ` TRUE `: Results in the portions of the data symbols (circles) in the margins outside the plot region to be visible.
        
Just these few scaling features and recognition that the same canvas can be rescaled over and over again shows the way forward to more creative techniques, such as adding data to the plot region on an secondary y axis. Starting with the previous example, we can alter margins to make room for the secondary axis on the right, rescale the canvas using ` plot.window() `, plot the data using ` plot.xy() `, and add the secondary axis to the right side of the plot region using ` Axis() `, without the need to learn any new functions or arguments.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Define margins leaving room for axes on the
# bottom, left, and right sides
par(
  omi = c(0, 0, 0, 0),
  mai = c(0.9, 0.9, 0.2, 0.9)
)

# Prepare the canvas for a new plot
plot.new()

# Scale the canvas 
plot.window(
  xlim = c(0.1, 1),
  xaxs = "i",
  ylim = c(0, 1),
  yaxs = "i",
  log = "x"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

# Plot example data points
plot.xy(
  xy = xy.coords(
    x = c(0.1, 1),
    y = c(0, 1)
  ),
  type = "p",
  xpd = TRUE
)

# Add an x axis
Axis(side = 1)

# Add a y axis
Axis(side = 2)

# Rescale the canvas for a secondary axis
plot.window(
  xlim = c(0.1, 1),
  xaxs = "i",
  ylim = c(10, 20),
  yaxs = "i",
  log = "x"
)

# Plot example data points using the secondary scaling
plot.xy(
  xy = xy.coords(
    x = c(0.15, 0.8),
    y = c(11, 19)
  ),
  type = "p",
  pch = 2
)

# Add the secondary y axis on the right side
Axis(side = 4)

# Add a box around the area where data is plotted
box()

# Add axis labels
title(
  xlab = "x",
  ylab = "y"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

While the functions necessary to add appropriate axis labels and legends to this graph have not yet been discussed, detailed understanding of just a few scaling controls and lower level graphing functions add tremendous potential for creativity and informed troubleshooting.

The graphics parameters and graphical function arguments that control margins, limits on the plot region, and axis types together give complete control over canvas scaling. The ` xpd ` graphical parameter or graphical function argument allows subsequent control over whether plot region symbols are visible when they are placed at coordinates that are in the margins outside the plot region. 


## `r sec1`.`r sec2 <- sec2 + 1; sec3 <- 0; sec2`. Taking full control of numerical axes

High level functions like ` plot.default() ` provide few features for direct control over formatting the axes. One strategy is to disable the axes when calling ` plot() `, then call ` Axis() ` directly to make use of all the features inaccessible via ` plot.default() `. Note that ` Axis() ` is an S3 abstraction, such that the function it actually calls depends on the arguments ` x ` and ` at ` passed to ` Axis `. When plotting axes based on numeric vectors, the function actually called is ` axis() `. Note that R is case-sensitive, so ` Axis() ` is technically a different function than ` axis() ` (though they sometimes have the same result).

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Define margins 
par(
  omi = c(0, 0, 0, 0),
  mai = c(0.9, 0.9, 0.2, 0.2)
)

# Plot points at coordinates 0, 0 and 1, 1 without axes
plot(
  x = c(0, 1),
  xlab = "x",
  y = c(0, 1),
  ylab = "y",
  axes = FALSE
)

# Add an x axis
axis(side = 1)

# Add a y axis
axis(side = 2)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

Description of functions and arguments being used for the first time:

- ` plot() ` or ` plot.default() `: A high level function for creating a new plot with a single line of code. The function ` plot() ` is an S3 abstraction, which in this case results in a call to ` plot.default() `.
    - ` axes `: Logical value specifying if axes should be created
        - ` FALSE `: Specifies that axes should not be drawn
- ` axis() `: Renders the symbolism of an axis with labeled ticks
    - ` side `: An integer specifying the side of the plot region upon which to place the axis (1 = bottom, 2 = left, 3 = top, 4 = right)
        - ` 1 ` or ` 2 `: Call with 1 creates the x axis and call with 2 creates the y axis

Notice that the ` axes = FALSE ` argument for ` plot() ` also results in the lack of a box drawn around the plot region. This feature is a consequence of the default value of the ` frame.plot ` argument being set to the same value as the ` axes ` argument (i.e., default value of ` frame.plot = axes ` specified in the arguments to ` plot.default() `.

```{r}
args(plot.default)
```

At this point, the convenience of using ` plot() ` may cause more confusion than it is worth. Perhaps customization at this level calls for more step-by-step code based on the dissection of ` plot.default() ` reviewed earlier.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Define margins 
par(
  omi = c(0, 0, 0, 0),
  mai = c(0.9, 0.9, 0.2, 0.2)
)

# Prepare the canvas and scale it
plot.new()
plot.window(
  xlim = c(0, 1),
  ylim = c(0, 1)
)

# Add an x axis
axis(side = 1)

# Add a y axis
axis(side = 2)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

The R base graphics package will often find an aesthetically pleasing style for the axes with default settings, but just a few arguments passed directly to the ` axis() ` function provide tremendous flexibility in formatting, including but not limited to: style and location of ticks and axis lines; style, location, and content of tick labels; and the location of axes relative to the plot region.


### `r sec1`.`r sec2`.`r sec3 <- sec3 + 1; sec3`. Customizing tick locations

The ` axis() ` function allows ticks to be located anywhere along the axes by passing a numeric vector of tick locations to the ` at ` argument. Therefore, any function that returns a numeric vector can be used to provide tick locations. Because aesthetically pleasing ticks are often at regular intervals, the ` seq() ` function is a good candidate for defining tick locations. However, use of the ` c() ` function to manually define the location of each tick is also possible. Regardless of the method used to create the vector for tick locations, an axis line is rendered from the first to the last tick specified. Note these axis lines are redundant and only the ticks and tick labels are a visible consequence of calls to ` axis() ` if a box is drawn around the plot region. For now, a box will not be drawn around the plot region to clearly observe the behavior of the ` axis() ` function.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

par(
  omi = c(0, 0, 0, 0),
  mai = c(0.9, 0.9, 0.2, 0.2)
)

plot.new()
plot.window(
  xlim = c(0, 1),
  ylim = c(0, 1)
)

# Add an x axis with custom ticks
axis(
  side = 1,
  at = seq(from = 0.1, to = 0.9, by = 0.2)
)

# Add a y axis with custom ticks
axis(
  side = 2,
  at = c(0, 0.15, 0.4, 0.55, 0.85, 1)
)

box(which = "outer")

```

Description of functions and arguments being used for the first time:

- ` axis() `: Renders the symbolism of an axis with labeled ticks
    - ` at `: A numeric vector specifying the locations of ticks
        - ` seq(from = 0.1, to = 0.9, by = 0.2) `: Generates a vector with a sequence of values at regular intervals for tick locations
        - ` c(0, 0.15, 0.4, 0.55, 0.85, 1) `: Generates a vector with directly specified values for tick locations
- ` seq() `: Creates a vector based on regular sequence of values
    - ` from `: A value for the beginning of the sequence
        - ` 0.1 `: Start the numerical sequence at 0.1
    - ` to `: A value for the end of the sequence
        - ` 0.9 `: End the numerical sequence at a value less than or equal to 0.9
    - ` by `: The interval between elements of the sequence
        - ` 0.2 `: Elements of the sequence should increment by 0.2 from the value at the beginning of the sequence

The ` axis() ` function will attempt to label the ticks based on the value specifying the tick location, if the formatting of the labels allow the labels to fit without overlap. Ticks will still be rendered where the labels do not fit, but the label will not be rendered. For example, several ticks are added to the y axis below, where only the lower-valued tick is labeled because the higher-valued tick is too close to allow a label to be rendered without overlap. The number of times the ` axis() ` function is called has no restrictions. The function might be called to draw attention to particular values of interest in a figure. For example, a tick is added at the value of 0.42 on the x axis below, to draw attention to and quantify this particular value on the graph. 

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

par(
  omi = c(0, 0, 0, 0),
  mai = c(0.9, 0.9, 0.2, 0.2)
)

plot.new()
plot.window(
  xlim = c(0, 1),
  ylim = c(0, 1)
)

# Add an x axis with custom ticks
axis(
  side = 1,
  at = seq(from = 0.1, to = 0.9, by = 0.2)
)
axis(
  side = 1,
  at = 0.42
)

# Add a y axis with custom ticks
axis(
  side = 2,
  at = c(-0.18, 0, 0.15, 0.38, 0.4, 0.55, 0.65, 0.85, 0.88, 1)
)

box(which = "outer")

```

The tick label for the x axis value at 0.42 fits on the axis based on the choice of the other tick labels. However, calling ` axis() ` (or any graphical rendering function) multiple times can create overlap of symbols, by design. Adjusting the location of tick labels to avoid overlap will be a later topic. Finally, the value of -0.18 was added as a tick location on the y axis. This tick is not visible because cropping outside the plot region applies to axes as it does to symbols representing data. In the case of an axis, cropping only applies to the boundaries of the plot region defined along that axis. In this case, the tick label at -0.18 is being cropped by the edge of the plot region specified by the buffer from y = 0. Setting the `xpd` argument to ` TRUE ` for the call to ` axis() ` will allow the cropped tick and associated axis line outside the plot region to be visible. 

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

par(
  omi = c(0, 0, 0, 0),
  mai = c(0.9, 0.9, 0.2, 0.2)
)

plot.new()
plot.window(
  xlim = c(0, 1),
  ylim = c(0, 1)
)

# Add an x axis with custom ticks
axis(
  side = 1,
  at = seq(from = 0.1, to = 0.9, by = 0.2)
)
axis(
  side = 1,
  at = 0.42
)

# Add a y axis with custom ticks
axis(
  side = 2,
  at = c(-0.18, 0, 0.15, 0.38, 0.4, 0.55, 0.65, 0.85, 0.88, 1),
  xpd = TRUE
)

box(which = "outer")

```

Description of functions and arguments being used for the first time:

- ` axis() `: Renders the symbolism of an axis with labeled ticks
    - ` xpd `: A logical value indicating whether plot region symbolism located at canvas coordinates in the margins outside the plot region should be visible (` TRUE `) or clipped (` FALSE `)
        - ` TRUE `: Results in the portions of the axis in the margins outside the plot region to be visible.

The function ` axis() ` only provides a tool for labeling the existing coordinate system on the canvas. The location of the plot region and scaling of the canvas are unaffected by calls to ` axis() `. Additional axes rendered on a different scale or plot region within the canvas would first require another call to ` plot.window() `.


### `r sec1`.`r sec2`.`r sec3 <- sec3 + 1; sec3`. Customizing tick labels

The basic character of tick labels can be customized using arguments to the ` axis() ` function. Both the content and the location of ticks are adjustable from this function. Though only customizations with arguments to ` axis() ` are covered here, even more creativity with tick labels (e.g., partial rotation of text) is possible by suppressing the labeling of ticks by setting the ` labels ` argument to ` FALSE ` and labeling ticks manually using the ` text() ` function with the argument ` xpd ` set to ` TRUE `.

If the locations of ticks are specified with the ` at ` argument, tick labels can also be defined explicitly with a vector of values passed to the ` labels ` argument. The length of the vectors for the ` at ` and ` labels ` arguments should be the same. As an example, values from 0 to 1 representing fractions of a whole might be visualized as the corresponding percentages by changing the tick labels. 

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Define margins 
par(
  omi = c(0, 0, 0, 0),
  mai = c(0.9, 0.9, 0.2, 0.2)
)

# Prepare the canvas and scale it
plot.new()
plot.window(
  xlim = c(0, 1),
  ylim = c(0, 1)
)

# Add an x axis
axis(
  side = 1,
  at = seq(from = 0, to = 1, by = 0.2),
  labels = seq(from = 0, to = 100, by = 20)
)

# Add a y axis
axis(
  side = 2,
  at = seq(from = 0, to = 1, by = 0.2),
  labels = c("0%", "20%", "40%", "60%", "80%", "100%")
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

Description of functions and arguments being used for the first time:

- ` axis() `: Renders the symbolism of an axis with labeled ticks
    - ` labels `: A vector of values specifying the labels for ticks. This argument can only be used if the locations of ticks are specified with the ` at ` argument, and the length of the vector of labels should match the length of the vector of tick locations.
        - ` seq(from = 0, to = 100, by = 20) `: Results in numeric tick labels corresponding to 0, 20, 40, 60, 80, and 100 percent
        - ` c("0%", "20%", "40%", "60%", "80%", "100%") `: Results in text tick labels corresponding to 0, 20, 40, 60, 80, and 100 percent, including the percent symbol
        
The automation of tick label generation is thus only limited by the imagination of how numerical or character vectors can be generated. However, the tick labels can always be hard coded to the exact symbolism desired with an explicitly defined vector of character strings. As with many of the labeling functions in R graphics, vectors of R expressions can also be used if mathematical notation is needed (see ` help(plotmath) `). Examples of that practice are provided in later materials.


### `r sec1`.`r sec2`.`r sec3 <- sec3 + 1; sec3`. Customizing axis locations

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Define margins 
par(
  omi = c(0, 0, 0, 0),
  mai = c(0.9, 1.8, 0.2, 0.2)
)

# Prepare the canvas for a new plot
plot.new()

# Scale the canvas 
plot.window(
  xlim = c(0, 1),
  ylim = c(0, 1)
)

# Add an x axis
axis(
  side = 1
)

# Add a y axis
axis(
  side = 2
)

plot.window(
  xlim = c(0, 2),
  ylim = c(0, 2)
)

# Add a y axis
axis(
  side = 2,
  line = 4
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```


## `r sec1`.`r sec2 <- sec2 + 1; sec3 <- 0; sec2`. Taking control of plotting data


## `r sec1`.`r sec2 <- sec2 + 1; sec3 <- 0; sec2`. Taking control of labeling
