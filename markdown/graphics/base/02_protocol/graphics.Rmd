---
title: "A deeper dive into graphing in base R"
---

Compiled on `r format(Sys.time(), format = "%e %B %Y %H:%M")`.

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)

indent <- function(length = 8) {
  return(
    paste(
      rep("&nbsp;", times = length),
      collapse = ""
    )
  )
}

sec1 = 0

```

`r indent()`
Typical tutorials on graphing in R aim to rapidly develop understanding of higher level graphing functions to allow users to generate useful graphs quickly. 
While this approach has merit in certain use cases, it tends to gloss over understanding of the lower level graphing functions that allow higher level graphing functions to work. 
A lack of proficiency with lower level graphing functions limits the creativity or specificity with which a user is able to create or adjust graphs in ways not supported by the higher level functions. 
A lack of understanding of the underlying operations of high level graphing functions also limits the skill and efficiency with which a user can troubleshoot graphing code that does not render as expected.

`r indent()`
This tutorial focuses on graphics tools typically loaded by default in an R session (i.e., base R) , including the **grDevices** package and the **graphics** package. 
Other graphing tools available include the  **grid** graphics package that is an alternative implementation of the **graphics** package. 
Popular higher level graphing tools that use the low lever tools in **grid** include the **lattice** and **ggplot2** packages. 
A full understanding of **grid** enhanced with the conveniences of **lattice** or **ggplot2** are another way to take full control over the appearance of complex data visualizations, though these topics are not covered here. 
All of these packages ultimately use the same graphics rendering interfaces provided by **grDevices**.
With detailed enough understanding of how each of these graphics packages organizes the canvas, rendering generated from any or all of them can be combined in the same figure.

`r indent()`
This tutorial is designed to provide a deeper dive into graphing with base R functions. 
It first reviews the basics of the graphics devices that are the rendering engines for all the graphics packages listed above.
Then the tutorial gradually builds the logical scaffolding of the organization of the graphics canvas used in base R, using examples that progressively build in complexity and introduce new features one step at a time. 
Care is taken to provide a thorough description each time a new function or a new argument to a function is introduced.
The intended use of this tutorial is for the reader to experiment with an open session in R (e.g., in RStudio) based on the code provided.
Experimentation with the values of parameters or values passed to arguments of functions is highly recommended to solidify understanding.
Reading this material without active experimentation will likely result in minimal retention of the concepts. 


```{r devices_heading, include = FALSE}
sec1 <- sec1 + 1
sec2 <- 0

hn <- paste0(sec1)
```
# `r hn`. Graphics devices

`r indent()`
Opening a graphics *device* creates a blank canvas upon which graphs will be rendered and opens a standardized interface for providing the instructions for drawing on that canvas.
Many graphing tools commonly used in R (including base R, grid, and ggplot) use the same collection of graphics devices that have the same interface to the rendering engine.
Therefore, if you understand the details of how to get each of the graphing tools to work with a specific area of the canvas, you can combine or overlap the results of any or all of these tools on the same canvas.

`r indent()`
Due to the standardization of the interface across the available graphics devices, defining graphics with the tools from any graphics package should create the same visualization, regardless of the device used for rendering.
You do not need to understand the nature of this interface to use it, but understanding its standardization explains how multiple graphics packages can make use of a common collection of devices for generating graphical products.
This feature provides the modularity that a given block of graphing code should create the same image regardless of whether it is rendered on the screen, rendered to a graphics file, or rendered to an embedded image in Rmarkdown.
However, the aspirational goals of this degree of modularity are also seldom completely realized.
Particular devices may not have all the features necessary to render all aspects of a given graphing tool.
For example, identical fonts or font sizes may not be available across all graphics devices, and the property of transparency in colors will not render properly on all devices.
You should expect differences between how different devices render the same instructions from a given graphics package.
These differences are sometimes subtle and sometimes catastrophic.
Early consideration or experimentation of the appropriate device that generates the proper format for the final product is encouraged to avoid unpleasant surprises near deadlines.

`r indent()`
A default device, sometimes called the "null device", is likely automatically open in a given R session.
The nature of the default device depends upon the platform you are using for development. 
In an R session operated from RStudio, the default device typically renders to the "Plots" tab, which is available in the bottom right panel in a default installation of RStudio.
The device that renders to the "Plots" tab is convenient, but the size and aspect ratio of graphs rendered in this panel will change depending on how your RStudio window is configured.
This lack of consistency in size and aspect ratio is problematic when refining figures or sharing code that generates figures.
Therefore, use of an external device often facilitates consistency through programmatic control over the dimensions of the figure and its contents.

`r indent()`
Let's first try graphing on your default device in an R session. 
First, we need an example of a commonly observed pattern in nature to provide a relevant practical example from environmental science. 
Exponential decay is a pattern we see everywhere in nature, and suggests the consumption of the stuff of interest as a constant fraction of the current amount.
More generally, visualization of time series data reflecting a system's behavior is a common need in environmental science.
For example, if we measure the concentration of a reactant periodically while a chemical reaction is occurring, we might see the concentration ($C$) of a reactant with limited availability decrease exponentially with time ($t$). 
For those familiar with chemistry, this pattern would be consistent with a first-order rate limitation of the reaction.
Let's say we are watching a chemical reactor over a 10 minute experiment, and we are somehow able to measure the concentration of a limiting reactant every minute.
In R, the `seq.default()` function might be used to define the vector of times at which we have measurements.

```{r devices_reactionTime}

# Assign a vector of measurement times to a variable
time <- seq.default(from = 0, to = 10, by = 1)

```

The variable `time` is now an numeric atomic vector of 11 values evenly spaced between 0 and 10.

*Functions and arguments being used for the first time*

- `seq.default()`: Creates a sequence of values 
    - `from`: The starting value of the sequence
        - `0` : The first value of the sequence should be 0
    - `to`: The end of the sequence should be less than or equal to this value
        - `10` : End the sequence at less than or equal to ten 
    - ` by `: The distance between consecutive elements of the sequence
        - `1` : Increment each element of the sequence by 1

`r indent()`
We can use the `print()` function to view a summary of the contents of the variable.

```{r device_reactionConc}

# Show a summary of the variable in standard output
print(x = time)

```

*Functions and arguments being used for the first time*

- `print()`: Prints a summary of the content of a variable to the output. In this case, the output ends up in the compiled Rmarkdown report. When using R from the console, the output is printed to the console. Typing a variable name in the console and hitting enter has the same effect as calling `print()` on that variable.
    - `x`: The object for which a summary should be generated
        - `time`: Prints the summary of the time vector. 

`r indent()`
If the reaction is continuously consuming the reactant at a rate of half of the current concentration per minute, then we expect the following exponential decay function to describe the change in concentration after some initial value $C_0$ at the beginning of the experiment.

$$
C = C_0 e^{-0.5 t}
$$
We can use this equation to calculate the concentration of the reactant at each measurement time, as defined in the vector of times created earlier
Let's assume the initial concentration is $\mathrm{5 \ mmol \ L^{-1}}$.

```{r devices_concCalc}

# Assign an exponential decay function of time to a variable
conc <- 5 * exp(-0.5 * time)

```

*Functions and arguments being used for the first time*

- `exp()`: computes a power of Euler's number
    - `x`: the number representing the exponent of Euler's number (i.e., $e^x$)
        - `0.5 * time`: An exponent allowing calculation of a decay rate of half the concentration per minute
 
The variable `conc` is now an numeric atomic vector with the same number of elements as `time`, where each element contains the calculation of the concentration derived from the corresponding element of `time`. 

```{r devices_printConc}

# Show a summary of the variable in standard output
print(x = conc)

```

`r indent()`
The data frame is a common data structure used in R for keeping corresponding data sets together in a table.
For example, we might want to keep the measurement times and the concentrations at those times together in a table.

```{r devices_makeReactDataFrame}

# Combine time and concentration vectors into a data frame
react <- data.frame(t = time, C = conc)

```

*Functions and arguments being used for the first time*

- `data.frame()`: Creates a data frame
    - `t`: Specifies the name of the first column as "t". Arguments can be passed to `data.frame` with names or generically without names. If names are added the columns will be named corresponding to the names of the arguments
        - `time`: Assigns the vector `time` as the values of the first column in the data frame
    - `C`: Specifies the name of the second column as "C". Arguments can be passed to `data.frame` with names or generically without names. If names are added the columns will be named corresponding to the names of the arguments
        - `conc`: Assigns the vector `conc` as the values of the first column in the data frame
    
`r indent()`
The variable `react` is now a table of values where the columns are named `t` for time and `C` for concentration and the rows contain values for each of these properties that correspond to a given measurement.
Note that you will get an error if you try to combine vectors of unequal length into a data frame.

```{r devices_printReactDataFrame}

# Show a summary of the variable in standard output
print(x = react)

```

`r indent()`
Among other indexing techniques, the `$` operator can be used to retrieve the original vector composing each column of the data frame.

The time vector that constitutes the first column...

```{r devices_pringTimeColumn}

# Show a summary of the data frame column in standard output
print(x = react$t)

```

The concentration vector that constitutes the second column...

```{r devices_printConcColumn}

# Show a summary of the data frame column in standard output
print(x = react$C)

```

`r indent()`
We have what we need to plot the data, but there is a more direct way to generate the data frame with a couple lines of code.
If we know ahead of time that we want these data in a table data structure, we can build the data frame more directly by starting with a single column for the time vector.

```
react <- data.frame(t = seq.default(from = 0, to = 10, by = 1))
```

Then, use the `$` operator to add a second column to the data frame with the calculated concentration vector.

```
react$C <- 5 * exp(-0.5 * react$t)
```

`r indent()`
The `plot()` function is an high level graphics function that makes several assumptions necessary to handle the details of creating a rudimentary graph.
When calling `plot()` in the code chunk below, the default device for plotting in Rmarkdown will result in the figure being rendered in the report immediately after the chunk.
For experimentation, you can cut and paste this code into an R console or script, and executing it will cause the graph to be rendered by your default graphics device.
Putting the calculated data and a call to `plot()` together, let's plot concentration of the reactant in our chemical reactor over time.

```{r devices_plotReactData}

# Define chemical reaction data
react <- data.frame(t = seq.default(from = 0, to = 10, by = 1))
react$C <- 5 * exp(-0.5 * react$t)

# Plot the exponential decay data
plot(x = react$t, y = react$C)

```

*Functions and arguments being used for the first time*

- `plot()`: An abstract convenience function for creating a plot with default properties very quickly
    - `x`: The vector specifying the values for data points on the abscissa (a.k.a. the x axis)
        - `react$t`: Data should be plotted on the x axis according to the time of measurement
    - `y`: The vector specifying the values for data points on the ordinate (a.k.a. the y axis)
        - `react$C`: Data should be plotted on the y axis according the the concentration associated with the time of measurement

`r indent()`
When making meaningful graphs, you will likely quickly reach a point where you want more flexibility or automation than the features offered by the default graphics device.
For example, the default device may have an aspect ratio that depends on how the window is currently configured.
When making publication-ready graphs, you will typically want direct control over that aspect ratio, or the sizing of the figure in general.
Fortunately, the default device can be replaced by calling functions from the `grDevices` package that will render the graphics elsewhere. Let's review a few of these options.


```{r devices_window_heading, include = FALSE}
sec2 <- sec2 + 1

hn <- paste0(sec1, ".", sec2)
```
## `r hn`. Rendering graphs directly to a new window

`r indent()`
Graphics devices launched by calling the `windows()` or `quartz()` functions will render to a new pop-up window on your operating system desktop.
A different device is needed for Windows or Mac computers because the nature of desktop windows are different depending on your operating system.
The `windows()` function will open a pop-up graphics device on a PC, and the `quartz()` function will open a pop-up graphics device on a Mac.
These devices cannot be demonstrated in an Rmarkdown report, so use the following code as a basis for experimentation.
While it may not be necessary in your environment, the `graphics.off()` function is being used here to be sure that any other graphics devices have been closed (other than the default).
Note the width, height, and font size for the graphics canvas are specified as arguments to the device functions here to demonstrate the control you gain with using a device other than the default.

For a PC:

``` 
# Shut down any existing devices
graphics.off()

# Define chemical reaction data
react <- data.frame(t = seq.default(from = 0, to = 10, by = 1))
react$C <- 5 * exp(-0.5 * react$t)

# Open the windows graphics device 
windows(
  width = 6,
  height = 5,
  pointsize = 12
)

# Plot the exponential decay data
plot(x = react$t, y = react$C)
```

For a Mac:

``` 
# Shut down any existing devices
graphics.off()

# Define chemical reaction data
react <- data.frame(t = seq.default(from = 0, to = 10, by = 1))
react$C <- 5 * exp(-0.5 * react$t)

# Open the quartz graphics device 
quartz(
  width = 6,
  height = 5,
  pointsize = 12
)

# Plot the exponential decay data
plot(x = react$t, y = react$C)
```

*Functions and arguments being used for the first time*

- `graphics.off()`: Close any graphics devices that are currently open (except the default)
- `windows()` for a PC or `quartz()` for a Mac: Opens a graphics device that writes to a pop-up window in the Windows operating system
    - `width`: Width of the canvas where graphical elements can be added
        - `6`: Width of the canvas will be 6 inches
    - ` height `: Height of the canvas where graphical elements can be added
        - `5`: Height of the canvas will b 5 inches
    - ` pointsize `: The default point size of characters and symbols
        - `12`: Rendering device will use a 12 point font for characters (12/72 = 1/6 of an inch). You might note from the documentation that 12 is the default value for this argument. Therefore, the same result would be obtained if this argument were removed from the function call.


```{r devices_graphicsFiles_heading, include = FALSE}
sec2 <- sec2 + 1

hn <- paste0(sec1, ".", sec2)
```
## `r hn`. Rendering graphs to vector or raster files

`r indent()`
You might want to render a graph directly to a file to send to a colleague or include in another report.
Multiple devices are available in the package `grDevices` that allow direct generation of industry standard graphics data files.

`r indent()`
The device opened by the `pdf()` function renders graphics to a file in vectorized postscript format (e.g., Adobe PDF files), and works on both Mac and PC computing platforms (as well as many others).
Key arguments to the function allow specifying the path to the file to be generated, as well as direct control over the basic size and default font point size for a given canvas.
As with many devices that create files, this device requires the `dev.off()` function to be called before the graphics file is written.
Another program will not be able to open the file being created until `dev.off()` is called to shut down the device.

`r indent()`
Calls to `graphics.off()` may be particularly useful when debugging graphing code that is creating files.
Calling this function before starting a new graph will make sure that no artifact graphics devices have been left open due to a fatal error in a previous execution of a script.
For devices that write to a file, previously opened devices writing to the same file name will likely cause this code to fail because the file cannot be overwritten if it is currently open.

`r indent()`
The following code generates a sample PDF file when run in an R session with the working directory set to where the file should be written.
You are encouraged to cut and paste this code into an R script, and experiment with running the script with different values for the arguments to confirm you understand the behaviors they control.
Note that the script may not run properly if you have the resulting graphics file open in a separate PDF viewer, if that PDF viewer locks the file while it is open.
SumatraPDF is a useful PDF viewer for development in Windows because it does not lock the file and automatically updates your view of the PDF file when it is rewritten by your R script.

``` 
# Shut down any existing devices
graphics.off()

# Define chemical reaction data
react <- data.frame(t = seq.default(from = 0, to = 10, by = 1))
react$C <- 5 * exp(-0.5 * react$t)

# Open the PDF graphics device 
pdf(
  file = "./graphics_test.pdf",
  width = 6,
  height = 5,
  pointsize = 12
)

# Plot the exponential decay data
plot(x = react$t, y = react$C)

# Terminate the graphics device
dev.off()
```
*Functions and arguments being used for the first time*

- `pdf()`: Opens a graphics device that writes to a postscript file
    - `file`: Path to the file where the graphics will be written
        - `"./graphics_test.pdf"`: Results in the vector graphics postscript file *graphics_test.pdf* being written to the working directory.
    - `width`: Width of the canvas where graphical elements can be added
        - `6`: Width of the canvas will be 6 inches
    - `height`: Height of the canvas where graphical elements can be added
        - `5`: Height of the canvas will b 5 inches
    - `pointsize`: The default point size of characters and symbols
        - `12`: Rendering device will use a 12 point font for characters (12/72 = 1/6 of an inch). You might note from the documentation that 12 is the default value for this argument. Therefore, the same result would be obtained if this argument were removed from the function call.
- `dev.off()`: Closes the most recently opened graphics device. For devices that write to a file (like `pdf()`). This typically needs to be called for the file to be written to the disk and available to be opened by other applications.

`r indent()`
If you are a Windows user, you may want to look into another vectorized graphics device opened by the `win.metafile()` function.
This device allows creation of vectorized graphics in Microsoft "enhanced metafile" format.
Graphics in this format can either be written to a file or written directly to your Windows clipboard to be pasted into other documents (e.g., MS Word or MS PowerPoint files).

`r indent()`
The `grDevices` package provides many options for generating raster image files.
For example, the `jpeg()` function opens a device that allows creation of image files in a compressed raster format that is very commonly used for pictures embedded in web pages.
Devices for raster files usually allow some way to control the quality of the image (a compromise with file size) by allowing specification of the pixel resolution.

``` 
# Shut down any existing devices
graphics.off()

# Define chemical reaction data
react <- data.frame(t = seq.default(from = 0, to = 10, by = 1))
react$C <- 5 * exp(-0.5 * react$t)

# Open the JPG graphics device 
jpeg(
  file = "./graphics_test.jpg",
  width = 6,
  height = 5,
  pointsize = 12,
  units = "in",
  res = 600
)

# Plot the exponential decay data
plot(x = react$t, y = react$C)

# Terminate the graphics device
dev.off()
```
*Functions and arguments being used for the first time*

- `jpeg()`: Opens a graphics device that writes to a postscript file
    - `file`: Path to the file where the graphics will be written
        - `"./graphics_test.jpg"`: Results in the compressed raster graphics file *graphics_test.jpg* being written to the working directory.
    - `width`: Width of the canvas where graphical elements can be added
        - `6`: Width of the canvas will be 6 inches (as indicated by `units` argument)
    - ` height `: Height of the canvas where graphical elements can be added
        - `5`: Height of the canvas will b 5 inches (as indicated by `units` argument)
    - ` pointsize `: The default point size of characters and symbols
        - `12`: Rendering device will use a 12 point font for characters (12/72 = 1/6 of an inch). You might note from the documentation that 12 is the default value for this argument. Therefore, the same result would be obtained if this argument were removed from the function call.
    - `units`: Units for the width and height arguments
        - `"in"`: Units of inches are used for width and height
    - `res`: Resolution in pixels per inch
        - `600`: A fairly high resolution of 600 pixels per inch for a high quality image. The size of the file generated is highly sensitive to the resolution selected.

Functions to open devices for other raster formats include `bmp()`, `png()`, and `tiff()`.


```{r include = FALSE}
sec2 <- sec2 + 1

hn <- paste0(sec1, ".", sec2)
```
## `r hn`. Graphing in Rmarkdown

`r indent()`
When Rmarkdown is being compiled to an html file, the default graphics device used by code chunks embedded in the markdown is `png()`.
This device creates a lossless portable graphics format raster file that can be embedded in the html and later displayed by a web browser application when viewing the file.
The graphics device is open by default, so an image can be embedded in a compiled Rmarkdown report without opening a device.
However, chunk options can be changed to allow graphics device arguments to be altered from their default values.
For example, the code chunk generating the graph below sets new values for chunk options that result in a customized canvas for the associated graphics device.
Code chunk options are set by including a list of key-value pairs after the r in the curly brackets specifying the beginning of the chunk.

```
 {r fig.align = 'center', fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}
```

Description of Rmarkdown chunk options being used for the first time:

- `fig.align`: Alignment of the resulting figure with respect to margins
    - `'center'`: Center the figure between the margins
- `fig.width`: Width of the canvas where graphical elements can be added
    - `6`: Width of the canvas will be 6 inches
- `fig.height`: Height of the canvas where graphical elements can be added
    - `5`: Width of the canvas will be 5 inches
- `dev.args`: List of arguments to be passed to the device
    - `list(pointsize = 12)`: The value of 12 for the `pointsize` argument will be passed to the rendering device, resulting in use of a 12 point font for characters (12/72 = 1/6 of an inch)
    
`r indent()`
The following code chunk provides an example of the use of these chunk options to specify the properties of the canvas created by the default `png()` device.
The edges of the full canvas are delineated using a call to the `box()` graphics function. Note the resulting graph appears immediately following the code chunk.

```
 {r fig.align = 'center', fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}
```
```{r fig.align = 'center', fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Define chemical reaction data
react <- data.frame(t = seq.default(from = 0, to = 10, by = 1))
react$C <- 5 * exp(-0.5 * react$t)

# Plot the exponential decay data
plot(x = react$t, y = react$C)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

*Functions and arguments being used for the first time*

- `box()`: Draws a box around predefined regions of a graphing canvas
    - `which`: Specifies which region of the graphing canvas around which to draw the box
        - `"outer"`: Results in a box around the outer edge of the canvas

`r indent()`
The default chunk options can be changed for the `knitr` package tools using the `opts_chunk$set()` function.
We are going to use the layout above for a considerable number of following examples, so let's change the defaults so we don't have to define these for every chunk using this graphics configuration.

```{r rmarkdown_layout}

knitr::opts_chunk$set(
  fig.align = "center",
  fig.width = 6,
  fig.height = 5,
  dev.args = list(pointsize = 12)
)

```

`r indent()`
A different device can be opened in a code chunk if the goal is to create a file rather than embed an image in the report.
Perhaps the goal is to generate a raster image of the graph independently of the compiled report.
For example, we can create a jpg file in a code chunk as demonstrated above, and put that file among the materials associated with this document.
Note that the `results = 'hide'` chunk option is set for this chunk to prevent the message returned by `dev.off()` from appearing in the report.

```
 {r results = 'hide'}
```
```{r rmarkdown_jpg, results = 'hide'}

# Define chemical reaction data
react <- data.frame(t = seq.default(from = 0, to = 10, by = 1))
react$C <- 5 * exp(-0.5 * react$t)

# Define the relative path to the image file
imagePath <- "./03_incremental/images/rmarkdown_example.jpg"

# Open the JPG graphics device 
jpeg(
  file = imagePath,
  width = 6,
  height = 5,
  pointsize = 12,
  units = "in",
  res = 600
)

# Plot the exponential decay data
plot(x = react$t, y = react$C)

# Draw a box around the outer edge of the canvas
box(which = "outer")

# Terminate the graphics device
dev.off()

```

`r indent()`
No graphics were embedded in the report immediately following the code chunk above, because this code is no longer using the default device for the chunk that would result in that behavior.
However, we can embed the image we created into the markdown using the following code chunk and the `include_graphics()` function from the `knitr` package.

`r indent()`
The function `normalizePath()` is used here to change the relative path into the absolute path.
The treatment of the working directory by the `knitr` package can be inconsistent.
Using the normalized path for the current machine and forcing `knitr` to work with absolute paths will prevent improper assumptions about the relationship between the working directory and the location of the Rmarkdown file.
These are assumptions that might cause this function to fail when the Rmarkdown file is not in the working directory.

```{r rmarkdown_embedImage}

# Normalize the relative image path to an absolute path
#   on the current file system
imagePathNormalized = normalizePath(path = imagePath)

# Embed the specified graphics file in the markdown report
knitr::include_graphics(path = imagePathNormalized, rel_path = FALSE)

```

*Functions and arguments being used for the first time*

- `normalizePath()`: Creates an absolute path to a file on the computer running the R code based on relative path provided.
    - `path`: The relative path to a file to be converted into an absolute path
        - `imagePath`: The relative path to the image file created by the previous chunk.
- `include_graphics()` from the package `knitr`: Embeds an image from a file into the compiled Rmarkdown report
    - `path`: The path to the file containing the image
        - `imagePathNormalized`: the absolute path to the file from the previous function call
    - `rel_path`: A switch for using relative paths
        - `FALSE`: Forces absolute paths relative to the current file system to be used to avoid inconsistencies in application of relative paths in `knitr`

You may notice that the default scaling for an embedded image is to expand to the full width of the report. Chunk options like `out.width` can be changed to control this behavior.

**Note to RStudio users:** The device used by RStudio to render graphics within the code editor window is not the same device used to generate the compiled document. Be sure to view figures in the final compilation to verify they have the desired characteristics, and do not assume the test figures in the coding window will necessarily match the final figure.


```{r include = FALSE}
sec1 <- sec1 + 1
sec2 <- 0

hn <- paste0(sec1)
```
# `r hn`. Dissecting the `plot()` and `plot.default()` functions

`r indent()`
Taking full control over your figures first requires a deeper understanding of what is happening when high-level functions like `plot()` are used.
Specifically, you need to understand how S3 objects work in R, and thus why `plot.default()` is the function that actually gets called when you call `plot()` with a numeric vector for the `x` argument.
Subsequently, understanding how `plot.default()` works requires understanding how the device canvas is scaled and how individual graphical elements are added to the canvas by lower level graphing functions.

`r indent()`
One way to explore the S3 abstraction for `plot()` is to look at the implementation of the function.
For functions implemented with R code, the implementation of the function can be viewed by typing the function name at the console prompt, without parentheses.

``` {r plot_code}

plot

```

`r indent()`
The entire implementation of this function is simply a call to the `UseMethod()` function, which means that the function that ultimately gets called depends on the data type of the first argument to the `plot(x, y, ...)` function.
In other words, a call to `plot` is not enough information to know what is going to happen, you also need to know the data type of the first argument to `plot(x, y, ...)`.
This abstraction is an artifact of the S3 implementation of object oriented programming, and is the reason why calling `help("plot", package = "base")` yields so little specific information about the arguments that can be used.
Calls to `plot()` are abstract and do not provide enough information to know what arguments will be valid.

`r indent()`
For the purposes of this document, calls to `plot()` will always pass an atomic vector to the first argument `x`, which results in the `plot.default()` function being called by `UseMethod()`.
Any arguments passed to `plot()` are also passed on to `plot.default()`.
Note that the implementation of `plot.default()` contains the far more complex code that is actually creating the components of the figure.

``` {r plot_defaultcode}

plot.default

```

For further exploration, note that calling `help("plot.default")` also yields far more detailed information about how to use the `plot()` function on vector arguments than `help("plot", package = "base")`. 

`r indent()`
For other examples of S3 functional abstractions, look at the implementation of the `print()` or `summary()` functions.
See if you can find the specific implementations of these functions for particular data types that might be passed as the first argument to the abstraction (e.g., `print.default()` or `print.data.frame()`).
While detailed knowledge of the benefits of these object-oriented principles of polymorphic classes is not strictly necessary to use R, deeper understanding of this topic will allow for more informed troubleshooting when a function does something unexpected.
If nothing else, deeper understanding of S3 abstractions will provide a pathway to finding more detailed documentation with `help()` on the functions you are actually using when calling abstract methods.

`r indent()`
While it may be cryptic if you are new to R, a careful inspection of the code for `plot.default()` reveals the fundamental steps of building a graph.
The function `plot.new()` moves to a new frame and prepares the corresponding canvas or part of a canvas for a new plot.
The function `box()` (called by the local function `localBox()`) is used to create lines at the edges of the plot region to delineate it from the rest of the canvas.
The function `plot.window()` (called by the local function `localWindow()`) creates the coordinate system for the canvas based on the location of the plot region.
The function `Axis()` (called by the local function `localAxis()`) creates the axes symbols relative to the edges of the plot region.
The function `plot.xy()` adds symbols to the plot region corresponding to the visualized data.
Finally, the function `title()` (called by the local function `localTitle()`) adds the labels for the axes and graph.
Constructing a graph directly using these functions is a way to override the assumptions `plot.default()` makes to allow quick construction of a graph, which opens the door to substantial creativity in figure construction.


```{r include = FALSE}
sec2 <- sec2 + 1

hn <- paste0(sec1, ".", sec2)
```
## `r hn`. Creating the canvas and defining the plot region

`r indent()`
The  function `plot.new()` is responsible for establishing a new canvas.
If previous graphing functions have been called on a given device, calls to `plot.new()` will also finalize graphing in the current frame and advance to the next frame.
The context of advancing to a new frame depends on the device being used and if any of the automated methods for creating multi-panel figures are active.
For example, if multi-panel tools are not activated and the pdf device is in use, calling `plot.new()` will start a new canvas on a new page in the pdf file, building pages in consecutive order.
The multiple potential behaviors of advancing frames is difficult to list exhaustively, but is not difficult to understand with experimentation in a given device and multi-panel scenario.

`r indent()`
In base R, the fundamental organization of the canvas is first determined by a rectangular subset of the canvas designated as the *plot region*.
The area within this region is where symbols representing data are conventionally rendered, though ultimately the coordinate system based on this plot region extends across the entirety of the canvas.
Symbols can technically be plotted anywhere, though they will only be visible if some part of them is within the coordinates defining the edges of the canvas.

`r indent()`
We can explore the basic construct of the canvas by calling `plot.new()` and then using the function `box()` to draw lines around both the edges of the canvas and the edges of the plot region.

```{r canvas_basic}

# Initialize a new canvas
plot.new()

# Draw a box around the plot region
box()

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

*Functions and arguments being used for the first time*

- `plot.new()`: Moves to a new frame and prepares the corresponding canvas or part of a canvas for a new plot.
- `box()`: Draws a box around predefined regions of a graphing canvas
    - No arguments implies default argument values including `which = "plot"`, which results in a box drawn around the plot region.
    
`r indent()`
A remaining mystery is why the plot region on the canvas above is in its current location.
As of yet, we have provided no information about the desired location of the plot region, so R must be making an assumption and hopefully we can override that assumption to allow more creativity with graph construction.
As it turns out, the location of the plot region is defined by a set of values for hierarchically nested outer and inner margins that together dictate the distance between the edges of the canvas and the edges of the plot region.
For now, we will focus on scaling the canvas for a single graph, which means the outer and inner margins on each edge of the canvas are additive.
In the case of a single graph (i.e., without multiple panels), the outer margins are often set to zero and the inner margins have sole control over the location of the edges of the plot region.
To solve the mystery of the location of the values for these margins, we need to start diving into the topic of the global graphics parameters accessible via the `par()` function.

`r indent()`
Calling `par()` in the console will produce a exhaustive, and perhaps a bit cryptic, list of global graphics parameters and their current values.
Calling `help("par")` will provide a detailed description of what each of the global graphics parameters controls, including the  `oma` or `omi` and `mar` or `mai` parameters that control the outer and inner margins.
Rather than taking space in this document, you are encouraged to explore this list and its documentation on your own.

`r indent()`
Passing a collection of character strings to `par()` representing parameter names (i.e., parameter names in quotes) will allow you to view the current values of a select list of global graphics parameters.
The default values for the outer margins of the default device in the following code chunk are...

```{r canvas_parOuterMarginView}

# Retrieve the current values of global graphics parameters
par("oma", "omi")

```

*Functions and arguments being used for the first time*

- `par()`: Allows the values of graphical parameters associated with the current open graphics device to be retrieved or altered.
    - `...`: To retrieve the current values of parameters, the `par()` function should be generically passed a collection of character strings representing parameter names
        - `"oma"` or `"omi"`: Returns the current setting for the graphical parameter defining the outer margins. The return value will be a vector with 4 elements designating the bottom, left, top, and right margins, in that order. The parameter `oma` is in the relative units of *lines*, which are sized relative to the point size of the font being used in labels in the margin of the graph. The parameter `omi` is in absolute units of inches, which is independent of font size. If either of these parameter values is changed using the `par()` function, the other is automatically updated based on the font size being used.

Nonzero outer margins are most useful for defining white space around multi-panel graphs, where the outer margins need to be differentiated from the inner margins of each panel (see `help("par")` for a visualization of the differences).
The outer margins are generally redundant when not using automated multi-panel graphing features (e.g., by changing the `mfrow` or `mfcol` global parameter), and thus the outer margins often default to zero in newly created devices.

`r indent()`
The default values for the inner margins of the default device in the following code chunk are...

```{r canvas_parInnerMarginView}

# Retrieve the current values of global graphics parameters
par("mar", "mai")

```

*Functions and arguments being used for the first time*

- `par()`: Allows the values of graphical parameters associated with the current open graphics device to be retrieved or altered.
    - `...`: To retrieve the current values of parameters, the `par()` function should be generically passed a collection of character strings representing parameter names
        - `"mar"` or `"mai"`: Returns the current setting for the graphical parameter defining the inner margins for an individual graph. The return value will be a vector with 4 elements designating the bottom, left, top, and right margins, in that order. The parameter `mar` is in the relative units of *lines*, which are sized relative to the point size of the font being used in labels in the margin of the graph. The parameter `mai` is in absolute units of inches, which is independent of font size. If either of these parameter values is changed using the `par()` function, the other is automatically updated based on the font size being used.

Do the values for `mai` (in inches) make sense relative to the location of the plot region from above?
Note that the image may be rescaled in your html viewer such that the absolute length of the spaces is not in inches, but the relative size of the spaces should align with the relative magnitude of the values representing the bottom, left, top, and right margins.

```{r canvas_basicMarginValueComparison, echo = FALSE}

# Initialize a new canvas
plot.new()

# Draw a box around the plot region
box()

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

`r indent()`
With the outer margins at zero, the inner margins are the only control on the location of the plot region for a given canvas.
Let's say we want to reduce the amount of white space outside the top and right edges of our plot region, because we do not anticipate those regions will require space for tick labels or axis labels outside the plot region.
We can reduce that space by sending named arguments to the `par()` function with the name being the parameter name and the passed value being the value for that parameter.
For example, `par(mai = c(1.02, 0.82, 0.25, 0.25))` should reduce the space on the top and right edges of the canvas to a quarter of an inch.
The function `c()` in R is a quick way to combine a collection of values into a vector, in this case an numeric atomic vector.
Let's try to change the inner margins and verify that it works by checking for the new values.
We can check both `mar` and `mai` to verify that the margins in units of lines are updated automatically.

```{r canvas_parMarginChange}

# Reset the inner margins (in inches)
par(mai = c(1.02, 0.82, 0.25, 0.25))

# Retrieve the current values of global graphics parameters
par("mar", "mai")

```

*Functions and arguments being used for the first time*

- `c()`: A generic function for combining objects into vectors
    - `...`: Arguments can be passed generically to `c()` without names. Unnamed arguments are combined into a vector without names attributes. Named arguments are combined into a vector with names attributes corresponding to the named arguments.
        - `c(1.02, 0.82, 0.25, 0.25)`: Results in the four provided values being combined into a numeric atomic vector (without names).
- `par()`: Allows the values of graphical parameters associated with the current open graphics device to be retrieved or altered.
    - `mai`: Named argument to set the value of the `mai` global parameter
        - `c(1.02, 0.82, 0.25, 0.25)`: Sets the graphics parameter for the margins based on a provided vector of four values (in inches) for the space between the edges of the canvas and the bottom, left, top, and right edges of the plot region. The function `c()` in R is a quick way to combine a collection of values into a vector, in this case an numeric atomic vector.
    
`r indent()`
Let's see the effect of changing the margin parameter on the location of the plot region.
Note that each code chunk in Rmarkdown has it's own default graphics device, so the following chunk will not remember changes in graphics parameters from the previous chunk.
Another call to `par()` is necessary to change the margin parameter for the default graphics device within the following chunk.

```{r canvas_changeMargins}

# Initialize a new canvas
plot.new()

# Reset the inner margins (in inches)
par(mai = c(1.02, 0.82, 0.25, 0.25))

# Draw a box around the plot region
box()

# Draw a box around the outer edge of the canvas
box(which = "outer")

```    

Here is the plot with the original `mai` settings of `r par("mai") ` for comparison...

```{r canvas_basicCompareMargins, echo = FALSE}

# Initialize a new canvas
plot.new()

# Draw a box around the plot region
box()

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

`r indent()`
This exercise with graphics parameters should provide you with the tools you need to experiment with values for the margins to be sure you understand how the graphics device responds.
Controls over the margins should be understood completely before moving on, because the nature of the coordinate system for the canvas established by `plot.window()` depends entirely on the locations of the edges of the plot region.
You can experiment with the behavior of outer margins as well, though you will not likely find these useful until working with automated tools for multi-panel figures.

`r indent()`
The ability to start a new plot region on the canvas anywhere you please also allows you to create multi-panel plots without using the automated tools.
Immense creativity in organizing the canvas arises from the fact that there are no limits to the number of times the margins can be reset on the same canvas.
Does the behavior of the following code make sense based on your understanding of the ability to set or reset margins on the same canvas?
Do you see why adding 2.5 inches to either the lower or upper margin makes white space for another plot region on a 5 inch high canvas?

```{r canvas_multipanel}

# Initialize a new canvas
plot.new()

# Reset the inner margins (in inches)
par(mai = c(2.5 + 1.02, 0.82, 0.25, 0.25))

# Draw a box around the plot region
box()

# Reset the inner margins (in inches)
par(mai = c(1.02, 0.82, 2.5 + 0.25, 0.25))

# Draw a box around the plot region
box()

# Draw a box around the outer edge of the canvas
box(which = "outer")

```


```{r include = FALSE}
sec2 <- sec2 + 1

hn <- paste0(sec1, ".", sec2)
```
## `r hn`. Specifying the coordinate system

`r indent()`
The coordinate system for the canvas must be defined before `plot.default()` can place any symbols on the canvas at desired locations.
The  function `plot.window()` is responsible for defining the coordinate system, which is defined based on assigning coordinate values to the two vertical edges and two horizontal edges of the rectangular plot region.
These coordinates have no influence on the location of the plot region on the canvas, because that location is defined by the values for the inner and outer margins (see above).

`r indent()`
The arguments passed to the `plot.window()` function to assign the vertical and horizontal coordinates of the plot region are `xlim` and `ylim`.
The `xlim` argument is expecting a vector of two values defining the coordinates for the left and right edges of the plot region along the abscissa (a.k.a. the x axis).
The `ylim` argument is expecting a vector of two values defining the coordinates for the bottom and top edges of the plot region along the ordinate (a.k.a. the y axis).
After defining the coordinates for the edges of the plot region, any other location on the canvas can be located using a scale for each of the x and y axes inferred from these values.
These inferred scales are typically either arithmetic or logarithmic in nature.
Substantial potential for creativity arises from the fact that the same plot region on a given canvas can be rescaled an unlimited number of times simply by calling the `plot.window()` function again without changing the margins.

`r indent()`
Let's use the chemical reactor exponential decay curve as the basis for scaling a canvas appropriate for plotting the data.
After defining the reactor data, we need to calculate the extremes of the x (time) an y (concentration) values to make sure the assigned coordinates of our plot region will allow all the data to be displayed.
The functions `min()` and `max()` are useful for calculating minimum and maximum summary statistics of vectors.
Based on these extremes, we have the information needed for the `xlim` and `ylim` arguments to the `plot.window()` function. 

```{r coord_basic}

# Define chemical reaction data
react <- data.frame(t = seq.default(from = 0, to = 10, by = 1))
react$C <- 5 * exp(-0.5 * react$t)

# Determine the limits of the data
xmin <- min(react$t)
xmax <- max(react$t)
ymin <- min(react$C)
ymax <- max(react$C)

# Initialize a new canvas
plot.new()

# Reset the inner margins (in inches)
par(mai = c(1.02, 0.82, 0.25, 0.25))

# Scale the canvas 
plot.window(
  xlim = c(xmin, xmax),
  ylim = c(ymin, ymax)
)

# Draw a box around the plot region
box()

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

*Functions and arguments being used for the first time*

- `min()`: Calculates the minimum value summary statistic of a collection of values
    - `...`: The min() function accepts collections of generic arguments without names, representing the objects to be assessed for minimum values
        - `react$t` or `react$C`: Causes the function to return the minimum of the time or concentration column
- `max()`: Calculates the maximum value summary statistic of a collection of values
    - `...`: The min() function accepts collections of generic arguments without names, representing the objects to be assessed for minimum values
        - `react$t` or `react$C`: Causes the function to return the maximum of the time or concentration column
- `plot.window()`: Scales the canvas, providing an orthogonal 2-dimensional coordinate system (x is horizontal and y is vertical) for locating graphical objects placed on the canvas by later calls to graphing functions.
    - `xlim`: Numerical vector with 2 elements specifying the coordinate values associated with the left and right edges of the plot region
        - `c(xmin, xmax)`: The `c()` function creates the simplest vector possible from the collection of values passed to it. This results in an numeric atomic vector with two values equaling `xmin` and `xmax` to be used as the coordinates of the left and right extremes of the plot region.
    - `ylim`: Numerical vector with 2 elements specifying the coordinate values associated with the bottom and top edges of the plot region
        - `c(ymin, ymax)`: The `c()` function creates the simplest vector possible from the collection of values passed to it. This results in an numeric atomic vector with two values equaling `ymin` and `ymax` to be used as the coordinates of the bottom and top extremes of the plot region.

The results are not particularly exciting.
The fact that we have established a coordinate system does not result in any graphical elements being added to the canvas.
The boxes aid in visualization of the plot region, but are unchanged by decisions about the scaling of the coordinate system.

`r indent()`
Fortunately, the `Axis()` or `axis()` functions provide a simple tool that will allow visualization of the coordinate system we just created.
Like `plot()`, `Axis()` is an object oriented S3 abstraction.
The function that actually does the work of building an axis depends on the types of the values passed to the `x` or `at` arguments of `Axis()`.
We are going to use the `axis()` function (function names are case-sensitive), which is typically the function that does the work of building conventional numeric axes.
While using either `Axis()` or `axis()` will work in the following examples, you will find that `help("axis")` provides much more detailed information about the potential to customize a numeric axis.
Customization of axes will be a topic for later discussion, and for now we will only be using the argument `side` to specify which side of the plot region should be labeled with an axis scale.

`r indent()`
Let's replace the box around the plot region with a scale on the x and y axes to reveal the consequences of establishing a coordinate system.
Specifying only the `side` argument for the `axis()` function will result in default behavior, where the graphing functions will automatically find a tick spacing and labeling scheme that is logical and avoids any visual overlap of symbols or labels.

```{r coord_axes}

# Define chemical reaction data
react <- data.frame(t = seq.default(from = 0, to = 10, by = 1))
react$C <- 5 * exp(-0.5 * react$t)

# Determine the limits of the data
xmin <- min(react$t)
xmax <- max(react$t)
ymin <- min(react$C)
ymax <- max(react$C)

# Initialize a new canvas
plot.new()

# Reset the inner margins (in inches)
par(mai = c(1.02, 0.82, 0.25, 0.25))

# Scale the canvas 
plot.window(
  xlim = c(xmin, xmax),
  ylim = c(ymin, ymax)
)

# Add scales to the x and y axes
axis(side = 1)
axis(side = 2)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

*Functions and arguments being used for the first time*

- `axis()`: Renders the symbolism of an axis with labeled ticks
    - `side`: An integer specifying the side of the plot region upon which to place the axis (1 = bottom, 2 = left, 3 = top, 4 = right)
        - `1` or `2`: Call with 1 creates the x axis symbols and call with 2 creates the y axis symbols
        
These scales should make sense relative to the calculations of minima an maxima from the chemical reaction data.
The measurements were taken from 0 to 10 minutes, so the x axis scale for the plotting region should span those values.
The initial concentration was $\mathrm{5 \ mmol \ L^{-1}}$ and was allowed to progress until only very small values were remaining, so the y axis should span from approximately zero to five.

`r indent()`
At this point, we need to remember that dissection of functions like `plot()` is useful for learning the details you might need to be more creative or to troubleshoot more quickly.
However, that does not mean that figures need always be generated at this level of functional granularity when higher level functions like `plot()` will provide the flexibility you need based on the arguments passed to it.
Recall that many arguments passed to `plot()` will be subsequently passed to the functions we have been discussing, ultimately achieving the exact same goals with the same lower level functions.
Here is an example of using the `plot()` function and some of its arguments we have not yet discussed to generate the same graph as the previous example.
We can remove several lines of code and arguments because the default behavior of `plot()` without those arguments is the same as several decisions we have made about how to define the coordinate system and how to show the axes.

```{r coord_usePlot}

# Define chemical reaction data
react <- data.frame(t = seq.default(from = 0, to = 10, by = 1))
react$C <- 5 * exp(-0.5 * react$t)

# Reset the inner margins (in inches)
par(mai = c(1.02, 0.82, 0.25, 0.25))

# Create the canvas, define the coordinate system, suppress plotting of data,
#   suppress axis labels, and suppress the box around the plot region
plot(
  x = react$t,
  xlab = "",
  y = react$C,
  ylab = "",
  type = "n",
  frame.plot = FALSE
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

*Functions and arguments being used for the first time*

- `plot()`: An abstract convenience function for creating a plot with default properties very quickly
    - `xlab`: A character string or R expression with the label for the x axis
        - `""`: Empty string resulting in no label
    - `ylab`: A character string or R expression with the label for the y axis
        - `""`: Empty string resulting in no label
    - `type`: The type of plot to generate
        - `"n"`: Passing the character "n" to `type` tells `plot()` to create the canvas, coordinate system, and axes, but not to plot any data. The data provided to the `x` and `y` parameters are still used to determine the coordinate system.
    - `frame.plot`: Switch controlling whether a box is drawn around the plot region
        - `FALSE`: Logical false setting results in the box not being drawn
        
Once you are comfortable with your understanding of the lower level functions being applied by higher level functions like `plot()`, you will find it second nature to bounce back and forth between using the higher or lower level functions, depending on your stylistic preference or the level of creativity needed.

`r indent()`
You may note from these scales that the point (0, 0) is not directly on the corner of the plot region.
To ensure all the data points will be visible, `plot.window()` adds a 4% buffer to the coordinates assigned to the edges of the plot region relative to the extreme's specified in the `xlim` and `ylim` vectors.
The actual coordinates of the edges of the plot region may be calculated as follows for an arithmetic scale, where the 1 and 2 subscripts denote the first and second elements of the xlim and ylim vectors.

$$
x_{left} = xlim_{1} - 0.04 (xlim_{2} - xlim_{1}) 
~~~~~~~~
x_{right} = xlim_{2} + 0.04 (xlim_{2} - xlim_{1})
$$

$$
y_{bottom} = ylim_{1} - 0.04 (ylim_{2} - ylim_{1})
~~~~~~~~
y_{top} = ylim_{2} + 0.04 (ylim_{2} - ylim_{1})
$$

`r indent()`
The application of buffering in determining the scaling from `xlim` and `ylim` is controlled by the type of axis designated by the `xaxs` and `yaxs` global graphics parameters.

```{r coord_parViewAxisTypes}
par("xaxs", "yaxs")
```

Most devices have parameter `xaxs` and `yaxs` set to "r" by default (which stands for "regular") and "regular" behavior is to add a 4% buffer around the data extremes specified.
Setting these parameters to "i" will force the coordinates of the edges of the plot region to align directly with the values provided in `xlim` and `ylim`.
Also, let's reintroduce the box around the plot region, allowing us to see its full delineation an alignment with the axes scales.

```{r coord_nobuffer}

# Define chemical reaction data
react <- data.frame(t = seq.default(from = 0, to = 10, by = 1))
react$C <- 5 * exp(-0.5 * react$t)

# Determine the limits of the data
xmin <- min(react$t)
xmax <- max(react$t)
ymin <- min(react$C)
ymax <- max(react$C)

# Initialize a new canvas
plot.new()

# Reset the inner margins (in inches)
# and change the axis types to "internal"
par(
  mai = c(1.02, 0.82, 0.25, 0.25),
  xaxs = "i",
  yaxs = "i"
)

# Scale the canvas 
plot.window(
  xlim = c(xmin, xmax),
  ylim = c(ymin, ymax)
)

# Add scales to the x and y axes
axis(side = 1)
axis(side = 2)

# Draw a box around the plot region
box()

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

The default determination of tick locations in this case may prevent a tick at 0 on both axes to avoid crowding of symbols.
However, note that the 0 location on both x an y axes are at the same point, denoting that the corner of the plot region is now at (0, 0) with no buffering.

`r indent()`
The function `plot.window()` may be called several times on the same canvas.
For example, we may need to call `plot.window()` for each plot region, if we have used changes to the margins to create more than one plot region on the same graph.
Here the motivation might be to compare stacked figure with the same scaling on the x axes, but different scaling on the y axes.

```{r coord_multipanelScaling}

# Initialize a new canvas
plot.new()

# Reset the inner margins (in inches) 
#   and rescale the coordinate system
par(mai = c(2.5 + 1.02, 0.82, 0.25, 0.25))
plot.window(
  xlim = c(0, 10),
  ylim = c(0, 5)
)

# Add scales to the x and y axes
axis(side = 1)
axis(side = 2)

# Draw a box around the plot region
box()

# Reset the inner margins (in inches) 
#   and rescale the coordinate system
par(mai = c(1.02, 0.82, 2.5 + 0.25, 0.25))
plot.window(
  xlim = c(0, 10),
  ylim = c(0, 100)
)

# Add scales to the x and y axes
axis(side = 1)
axis(side = 2)

# Draw a box around the plot region
box()

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

`r indent()`
We may also need to reestablish a new coordinate system based on the same plot region (i.e., without changing margins), if we want to put data on the same graph but with a very different secondary y axis scale on the right side of the plot region.
Also, there are no rules that say that the coordinate system has to increase in value from left to right or from bottom to top.
Inverting plots in base R is accomplished by reversing the scale for the associated axis in the coordinate system.
In the following example, let's rescale the plot region designed for the chemical reaction data and create a corresponding y axis on the right side to reflect an inverted scale from 0 at the top to 100 at the bottom.
We'll keep the same x axis scaling for both coordinate systems, as is common practice when scaling data sets at multiple scales on the same axes.
Therefore, there is no need to render the symbols for the x axis scaling more than once.
Note that the margins have been changed here to make room for the ticks and tick labels for the secondary y axis the right side.

```{r coord_secondAxisScaling}

# Define chemical reaction data
react <- data.frame(t = seq.default(from = 0, to = 10, by = 1))
react$C <- 5 * exp(-0.5 * react$t)

# Determine the limits of the data
xmin <- min(react$t)
xmax <- max(react$t)
ymin <- min(react$C)
ymax <- max(react$C)

# Initialize a new canvas
plot.new()

# Reset the inner margins (in inches)
par(mai = c(1.02, 0.82, 0.25, 0.82))

# Scale the canvas for the left y axis
plot.window(
  xlim = c(xmin, xmax),
  ylim = c(ymin, ymax)
)

# Add scales to the x and left y axes
axis(side = 1)
axis(side = 2)

# Draw a box around the plot region
box()

# Scale the canvas for the right y axis
plot.window(
  xlim = c(xmin, xmax),
  ylim = c(100, 0)
)

# Add scales to the right y axis
axis(side = 4)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```


```{r include = FALSE}
sec2 <- sec2 + 1

hn <- paste0(sec1, ".", sec2)
```
## `r hn`. Plotting the data

`r indent()`
Once a coordinate system is defined, graphical symbols can now be added to the canvas in as many layers as desired.
Lower layers will still be visible, unless opaque elements are added on top of them.
The `plot.default()` function uses the function `plot.xy()` to add symbols representing data to the plot region. 
The first argument `xy` to the function `plot.xy()` is expected to be a list of vectors characterizing the coordinates to be plotted.
This list can be conveniently constructed using the `xy.coords()` function with arguments specifying equal-length vectors of x and y coordinates, where the length corresponds to the number of data points to be plotted.

```{r plotdata_plotxy}

# Define chemical reaction data
react <- data.frame(t = seq.default(from = 0, to = 10, by = 1))
react$C <- 5 * exp(-0.5 * react$t)

# Determine the limits of the data
xmin <- min(react$t)
xmax <- max(react$t)
ymin <- min(react$C)
ymax <- max(react$C)

# Initialize a new canvas
plot.new()

# Reset the inner margins (in inches)
par(mai = c(1.02, 0.82, 0.25, 0.25))

# Scale the canvas 
plot.window(
  xlim = c(xmin, xmax),
  ylim = c(ymin, ymax)
)

# Add scales to the x and y axes
axis(side = 1)
axis(side = 2)

# Draw a box around the plot region
box()

# Plot the reactant data
xyreact <- xy.coords(x = react$t, y = react$C)
plot.xy(xy = xyreact, type = "p")

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

*Functions and arguments being used for the first time*

- `xy.coords()`: Creates a coordinate list for a bivariate data set to be plotted
    - `x`: Numerical vector of values for the x coordinate of each data point graphed
        - `react$t`: Data points are plotted on the x axis at the times of measurements of the reactant concentrations
    - `y`: Numerical vector of values for the y coordinate of each data point graphed
        - `react$C`: Data points are plotted on the y axis at the concentrations corresponding to the measurement times
- `plot.xy()`: Renders the symbols corresponding to a bivariate scatter plot on the canvas
    - `xy`: A coordinate list specifying information about the x and y coordinates for a set of data to be plotted.
        - `xyreact`: The object returned by a call to `xy.coords()` to define the x and y plotting data for the chemical reaction experiment
    - `type`: The character string code for the type of scatter plot to render
        - `"p"`: Results in data being plotted as point symbols in the scatter plot

`r indent()`
The `plot.xy()` function offers substantial flexibility in the symbols used to reflect the values of the data.
The argument `type` controls whether data are represented by point symbols, line symbols connecting data, or a combination of both (see `help("plot.default")` for details).
The key characteristics of `col`,`lwd`, `pch`, `cex`, `lty`, and `lwd` are both global graphics parameters and arguments to `plot.xy()`.
Changing the global graphics parameter value will change the default value used if a corresponding argument to a graphics function is not specified.
However, a specified argument to a graphics function function will typically override the global parameter value.
Changing the global graphics parameter may change the character of more symbols than just those used to represent the data.

For a brief description  (see `help("par")` for details):
- The `col` parameter or argument changes the color of the point or line symbols.
- The `lwd` parameter or argument changes the width of the lines in the point or line symbols.
- The `pch` parameter or argument changes the type of point symbol used (circles, squares, triangle, etc.).
- The `cex` parameter or argument changes the size of the point symbol used, as a factor of the default point size.
- The `lty` parameter changes the type of line symbol used (dotted, dashed, etc.).

These are the characteristics of symbols you are likely to want to change most often, but this list is not exhaustive. Also, we are leaving for later discussion the fact that these parameters or arguments can all be vectors of multiple values rather than individual values.

`r indent()`
Demonstrating these characteristics individually is outside the scope of this tutorial and experimentation is probably a better way to develop understanding of these controls.
Here is an example where all of these symbol characteristics discussed have been altered either as global graphics parameters or arguments to `plot.xy()`.
Note that the value returned by `xy.coords()` is being passed directly to the `xy` argument of `plot.xy()`, eliminating the need to define another variable. 
You are encouraged to experiment to convince yourself you understand the consequences of altering these symbol characteristics at either the global level or as arguments to specific graphing functions.

```{r plotdata_style}

# Define chemical reaction data
react <- data.frame(t = seq.default(from = 0, to = 10, by = 1))
react$C <- 5 * exp(-0.5 * react$t)

# Determine the limits of the data
xmin <- min(react$t)
xmax <- max(react$t)
ymin <- min(react$C)
ymax <- max(react$C)

# Initialize a new canvas
plot.new()

# Reset the inner margins (in inches)
# and change the default point symbol
par(
  mai = c(1.02, 0.82, 0.25, 0.25),
  pch = 3
)

# Scale the canvas 
plot.window(
  xlim = c(xmin, xmax),
  ylim = c(ymin, ymax)
)

# Add scales to the x and y axes
axis(side = 1)
axis(side = 2)

# Draw a box around the plot region
box()

# Plot the reactant data
plot.xy(
  xy = xy.coords(x = react$t, y = react$C), 
  type = "b",
  col = "darkorange",
  lwd = 2,
  cex = 0.5,
  lty = "dotted"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

`r indent()`
Perhaps this is a good time to revisit the higher level functions.
The previous example does not actually require the granularity of lower level functions we are using.
Here is an example of the same figure generated by a call to `plot()`.
Again, several lines of code can be removed because the decisions we have made about the coordinate system and axes are identical to the assumptions made by `plot()`.
This time, we don't need any new functions or arguments that we have not already used.

```{r plotdata_usePlot}

# Define chemical reaction data
react <- data.frame(t = seq.default(from = 0, to = 10, by = 1))
react$C <- 5 * exp(-0.5 * react$t)

# Reset the inner margins (in inches)
# and change the default point symbol
par(
  mai = c(1.02, 0.82, 0.25, 0.25),
  pch = 3
)

# Create the canvas, define the coordinate system,
#   plot the reactant data, suppress default axis labels,
#   and change the default symbol characteristics
plot(
  x = react$t,
  xlab = "",
  y = react$C,
  ylab = "",
  type = "b",
  col = "darkorange",
  lwd = 2,
  cex = 0.5,
  lty = "dotted"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

`r indent()`
As noted earlier, we can add as many layers of data as needed.
For example, we may want to visualize the concentration of a product of our hypothetical chemical reaction alongside the reactant.
Let's say that the initial concentration of our product is $\mathrm{4 \ mmol \ L^{-1}}$ and stoichiometry dictates that the reaction requires two of the reactant compounds to generate one product compound.
The code defining the concentration of our product (`react$P`) at any given time would be `4 + 0.5 * (5 - react$C)`.
In other words, the amount of product created above the initial concentration would be half of the amount of the reactant consumed at any given time of measurement.

```{r plotData_productCalc}

# Define chemical reaction data
react <- data.frame(t = seq.default(from = 0, to = 10, by = 1))
react$C <- 5 * exp(-0.5 * react$t)
react$P <- 4 + 0.5 * (5 - react$C)

# Print a summary of the variable to standard output
print(x = react)

```

We will also need to reintroduce direct calculation of our minima and maxima for the specification of `xlim` and `ylim` to be sure that the data from both our data sets will be visible in our plot region after creating the coordinate system.
We can use an additional call to `plot.xy()` to layer the concentrations of the reaction product on top of the concentrations of the reactant created by the `plot()` function.
The high level function is just using the low level functions to do its job, so mixing and matching high and low level tools is not a problem.

```{r plotData_product}

# Define chemical reaction data
react <- data.frame(t = seq.default(from = 0, to = 10, by = 1))
react$C <- 5 * exp(-0.5 * react$t)
react$P <- 4 + 0.5 * (5 - react$C)

# Determine the limits of the data
xmin <- min(react$t)
xmax <- max(react$t)
ymin <- min(react$C, react$P)
ymax <- max(react$C, react$P)

# Reset the inner margins (in inches)
par(mai = c(1.02, 0.82, 0.25, 0.25))

# Create the canvas, define the coordinate system,
#   plot the reactant data, and suppress default axis labels
plot(
  x = react$t,
  xlim = c(xmin, xmax),
  xlab = "",
  y = react$C,
  ylim = c(ymin, ymax),
  ylab = ""
)

# Plot the product data
plot.xy(
  xy = xy.coords(x = react$t, y = react$P),
  type = "p",
  pch = 2,
  col = "darkorange"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

`r indent()`
We can also add layers after changes in the location of the plot region and rescaling of the coordinate system.
Let's add the reactant and the product to separate plots, building on the example with multiple panels from resetting the margins.
Many more convenient methods are available for creating gridded alignments of multi-panel plots.
See `mfrow` or `mfcol` global graphics parameters for a simple example.
However, none of these conveniences are more flexible and configurable than direct manipulation of the plot region and coordinate system.

```{r plotData_multipanel}

# Define chemical reaction data
react <- data.frame(t = seq.default(from = 0, to = 10, by = 1))
react$C <- 5 * exp(-0.5 * react$t)
react$P <- 4 + 0.5 * (5 - react$C)

# Initialize a new canvas
plot.new()

# Determine the limits of the data
xmin <- min(react$t)
xmax <- max(react$t)
ymin <- min(react$C)
ymax <- max(react$C)

# Reset the inner margins (in inches) 
#   and rescale the coordinate system
par(mai = c(2.5 + 1.02, 0.82, 0.25, 0.25))
plot.window(
  xlim = c(xmin, xmax),
  ylim = c(ymin, ymax)
)

# Add scales to the x and y axes
axis(side = 1)
axis(side = 2)

# Draw a box around the plot region
box()

# Plot the reactant data
plot.xy(
  xy = xy.coords(x = react$t, y = react$C),
  type = "p"
)

# Determine the limits of the data
ymin <- min(react$P)
ymax <- max(react$P)

# Reset the inner margins (in inches) 
#   and rescale the coordinate system
par(mai = c(1.02, 0.82, 2.5 + 0.25, 0.25))
plot.window(
  xlim = c(xmin, xmax),
  ylim = c(ymin, ymax)
)

# Add scales to the x and y axes
axis(side = 1)
axis(side = 2)

# Draw a box around the plot region
box()

# Plot the product data
plot.xy(
  xy = xy.coords(x = react$t, y = react$P),
  type = "p",
  pch = 2,
  col = "darkorange"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```


```{r include = FALSE}
sec2 <- sec2 + 1

hn <- paste0(sec1, ".", sec2)
```
## `r hn`. Annotating a figure

`r indent()`
The `title()` function is a high level tool for labeling different parts of the graph with minimal information required.
Provided the appropriate room is left by the margins, the `title()` function will add axis labels based on character strings or expressions passed to the `xlab` and `ylab` arguments.

```{r labelGraph_title}

# Define chemical reaction data
react <- data.frame(t = seq.default(from = 0, to = 10, by = 1))
react$C <- 5 * exp(-0.5 * react$t)

# Determine the limits of the data
xmin <- min(react$t)
xmax <- max(react$t)
ymin <- min(react$C)
ymax <- max(react$C)

# Initialize a new canvas
plot.new()

# Reset the inner margins (in inches)
par(mai = c(1.02, 0.82, 0.25, 0.25))

# Scale the canvas 
plot.window(
  xlim = c(xmin, xmax),
  ylim = c(ymin, ymax)
)

# Add scales to the x and y axes
axis(side = 1)
axis(side = 2)

# Draw a box around the plot region
box()

# Label the x and y axis
title(xlab = "Time", ylab = "Concentration")

# Plot the reactant data
xyreact <- xy.coords(x = react$t, y = react$C)
plot.xy(xy = xyreact, type = "p")

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

*Functions and arguments being used for the first time*

- `title()`: Renders the labels on various elements of a graphing canvas
    - `xlab`: A character string (or expression) specifying the label for the x axis
        - `"Time"`: Results in the x axis being labeled with "Time"
    - `ylab`: A character string (or expression) specifying the label for the y axis
        - `"y"`: Results in the y axis being labeled with "Concentration"

`r indent()`
As a more flexible alternative to `title()`, the `mtext()` function is a lower level tool that provides a much more configurable method for adding labels to the margins of graphs (such as axes labels or tick labels).
Use of the `mtext()` function here only requires specifying the side and the distance from the plot region for the location of the label.
The `side` argument functions similarly to that of the `axis()` function, where 1, 2, 3, and 4 correspond to the bottom, left, top, and right sides of the plot region.
The `line` argument specifies the distance from the plot region toward the edge of the canvas for the text.
This value passed to the `line` argument should be in units of lines of text, the size of which is determined by the font size for text in the margins (similar to the lines units used for the `oma` or `mar` specification of margin size).

```{r labelGraph_mtext}

# Define chemical reaction data
react <- data.frame(t = seq.default(from = 0, to = 10, by = 1))
react$C <- 5 * exp(-0.5 * react$t)

# Determine the limits of the data
xmin <- min(react$t)
xmax <- max(react$t)
ymin <- min(react$C)
ymax <- max(react$C)

# Initialize a new canvas
plot.new()

# Reset the inner margins (in inches)
par(mai = c(1.02, 0.82, 0.25, 0.25))

# Scale the canvas 
plot.window(
  xlim = c(xmin, xmax),
  ylim = c(ymin, ymax)
)

# Add scales and labels to the x and y axes
axis(side = 1)
mtext(text = "Time", side = 1, line = 2.5)
axis(side = 2)
mtext(text = "Concentration", side = 2, line = 2.5)

# Draw a box around the plot region
box()

# Plot the reactant data
xyreact <- xy.coords(x = react$t, y = react$C)
plot.xy(xy = xyreact, type = "p")

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

*Functions and arguments being used for the first time*

- `mtext()`: Renders text in the margins of a graph with orientation of the text depending on the side of placement
    - `side`: An integer specifying the side of the plot region upon which to place the text (1 = bottom, 2 = left, 3 = top, 4 = right)
        - `1` or `2`: Call with 1 creates the x axis label and call with 2 creates the y axis label
    - `line`: Distance from the axis toward the edge of the canvas for the text, in units of lines. Lines are relative units depending on the font size of text in the margins.
        - `2.5`: 2.5 times the margin text font size from the plot region toward the edge of the canvas

`r indent()`
The same graph can be accomplished using the higher level function `plot()`.
However, a critical element of the axis labels is still missing.
Whenever a numerical scale is provided on a graph, any applicable units must be specified for the numbers read from the graph to have any meaning.
For proper annotation, we may want to put mathematical notation in text on the figure.
For most labels, R will allow specification of the label as an expression rather than a character string.
An expression is a bit of unresolved R code that is interpreted later.
In this case it is interpreted by the rendering device in a mathematical formatting language specified by plotmath in `grDevices`.
See `help("plotmath")` for detailed documentation.
One key to understanding plotmath is that space characters have no influence. Space is created in the math using the "~" character, and breaks between terms without space are designated using the "\*" character.
For example, if we want to use exponents of units in our label, the R expression created by `expression(Concentration ~ "(" * mmol ~ L^-1 * ")")` will be rendered in the figure as $\mathrm{Concentration \ (mmol \ L^{-1})}$.
The language of plotmath takes some practice, but if you are diligent with separating every term with "~" and "*" characters, you will avoid the most common errors in compilation.
Note that adding the exponent required a bit more space in the left margin (increased from 0.82 to 0.92 inches) to prevent the y axis heading from running off the edge of the canvas.

```{r labelGraph_plot}

# Define chemical reaction data
react <- data.frame(t = seq.default(from = 0, to = 10, by = 1))
react$C <- 5 * exp(-0.5 * react$t)

# Reset the inner margins (in inches)
par(mai = c(1.02, 0.92, 0.25, 0.25))

# Create the canvas, define the coordinate system,
#   plot the reactant data, and add axis labels
plot(
  x = react$t,
  xlab = "Time (min)",
  y = react$C,
  ylab = expression(Concentration ~ "(" * mmol ~ L^-1 * ")")
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

*Functions and arguments being used for the first time*

- `expression()`: Create an unevaluated R expression from the raw code in the argument
    - `...`: The function `expression()` accepts generic arguments without names, where the argument is accepted as unevaluated code
        - `Concentration ~ "(" * mmol ~ L^-1 * ")"`: raw code that is passed to the rendering device for evaluation. In this case, the rendering device will interpret the expression in the `plotmath` formatting language for rendering with mathematical symbols (in this case, $\mathrm{Concentration \ (mmol \ L^{-1})}$).

`r indent()`
Adding arbitrary labels within the plot region is another common need in annotating a figure.
The `text()` function allows text to be added to the canvas using a location defined in the coordinate system created by `plot.window()`.
For example, we might want to add the equation for the curve to the figure above.
The gives us an excuse to review a fancier example of a `plotmath` expression.
The `adj` argument to `text` allows control of the justification of the text relative to the location we provide using x and y coordinates.
In this case, passing the single value of zero is left justification, meaning the defined x and y coordinates will be centered on the left edge of the added text.
The function `text()` is another S3 abstraction, so you might want to review `help("text.default")` for more detailed information about adding text with numerical coordinates.

```{r labelGraph_equation}

# Define chemical reaction data
react <- data.frame(t = seq.default(from = 0, to = 10, by = 1))
react$C <- 5 * exp(-0.5 * react$t)

# Reset the inner margins (in inches)
par(mai = c(1.02, 0.92, 0.25, 0.25))

# Create the canvas, define the coordinate system,
#   plot the reactant data, and add axis labels
plot(
  x = react$t,
  xlab = "Time (min)",
  y = react$C,
  ylab = expression(Concentration ~ "(" * mmol ~ L^-1 * ")")
)

# Add the equation to the figure
text(
  x = 3,
  y = 2,
  labels = expression(italic(C == 5 * e^{-0.5 * t})),
  adj = 0
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

*Functions and arguments being used for the first time*

- `text()` or `text.default()`: Add a text label based on the coordinate system established by `plot.window()`
    - `x`: Position of the text relative to the x axis
        -`3`: Hard coded to the value 3 on the x axis
    - `y`: Position of the text relative to the y axis
        -`2`: Hard coded to the value 3 on the y axis
    - `labels`: Text or expression to be added as a label
        - `expression(italic(C == 5 * e^{-0.5 * t}))`: An plotmath expression that will render as $C = 5 e^{-0.5 t}$
    - `adj`: Justification of the text relative to the x and y coordinates provided

`r indent()`
A legend is often helpful to allow quick interpretation of the symbols on a plot, especially if multiple data sets are plotted together on the same axes.
Let's practice adding a legend to the previous example with plots of both a reactant and product of our hypothetical chemical reaction.
To make our future lives easier, we will first change the example to define the symbolism of our plots at the beginning of the code creating the figure.
This practice will allow us to change the symbols used both in the plot and in the legend from a single location in the code.
When computer programming, a generally healthy practice is to define a variable for a value needed more than once, rather than "hardcoding" that value by manually copying it multiple times through a program.
"Hardcoding" the same value more than once creates headaches for any value that might need to be changed in the future, yet needs to stay consistent through a given execution of the program.
When building plots for publication, the need to adjust the symbolism in revisions of a manuscript is extremely common, and we quickly benefit by making those changes easy to accomplish.

`r indent()`
The `legend()` function uses the coordinate system of the canvas to define a location for the legend, in addition to `xjust` and `yjust` arguments to determine the justification of the legend relative to that location.
The central area on the right side of the plot region does not have any data, so let's put the legend there.
We can use our `xmin` and `ymin` calculations to define a point in the middle of the right edge of the plot region.
Then we can make sure the legend is placed to the left of that location in the x direction (`xjust = 1`) and centered in the y direction (`yjust = 0.5`).
We can turn off the box around the legend with the `bty` argument.
Finally, the text, symbols, and colors for the plots listed in the legend are defined with vectors passed to the `legend`, `pch`, and `col` arguments, respectively.

```{r labelGraph_legend}

# Define chemical reaction data
react <- data.frame(t = seq.default(from = 0, to = 10, by = 1))
react$C <- 5 * exp(-0.5 * react$t)
react$P <- 4 + 0.5 * (5 - react$C)

# Determine the limits of the data
xmin <- min(react$t)
xmax <- max(react$t)
ymin <- min(react$C, react$P)
ymax <- max(react$C, react$P)

# Define the symbols and colors for the plots
reactantSymbol <- 1
reactantColor <- "black"
productSymbol <- 2
productColor <- "darkorange"

# Reset the inner margins (in inches)
par(mai = c(1.02, 0.92, 0.25, 0.25))

# Create the canvas, define the coordinate system,
#   plot the reactant data, add axis labels,
#   and alter default symbol characteristics
plot(
  x = react$t,
  xlim = c(xmin, xmax),
  xlab = "Time (min)",
  y = react$C,
  ylim = c(ymin, ymax),
  ylab = expression(Concentration ~ "(" * mmol ~ L^-1 * ")"),
  pch = reactantSymbol,
  col = reactantColor
)

# Plot the product data
plot.xy(
  xy = xy.coords(x = react$t, y = react$P),
  type = "p",
  pch = productSymbol,
  col = productColor
)

# Add the equation to the figure
text(
  x = 3,
  y = 2,
  labels = expression(italic(C == 5 * e^{-0.5 * t})),
  adj = 0,
  col = reactantColor
)

# Add a legend
legend(
  x = xmax,
  y = 0.5 * (ymax - ymin),
  bty = "n",
  xjust = 1,
  yjust = 0.5,
  legend = c("Reactant", "Product"),
  pch = c(reactantSymbol, productSymbol),
  col = c(reactantColor, productColor)
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

*Functions and arguments being used for the first time*

- `legend()`: Add a legend to a graph at a location based on the coordinate system established by `plot.window()`
    - `x`: Position of the text relative to the x axis
        -`xmax`: Use the values calculated for `xlim` to put the legend on the right side of the plot region
    - `y`: Position of the text relative to the y axis
        -`0.5 * (ymax - ymin)`: Use the values calculated for `ylim` to put the legend halfway up the right side of the plot region
    - `bty`: Type of box to use around the legend
        - `"n"`: Do not put a box around the legend
    - `xjust`: Justification of the legend relative to the x coordinate provided
        - `1`: Places the legend fully to the left of the x coordinate provided
    - `yjust`: Justification of the legend relative to the y coordinate provided
        - `0.5`: Places the legend centered on the y coordinate provided
    - `legend`: A vector of character strings for each label in the legend
        - `c("Reactant", "Product")`: The labels correspond to the reactant and product concentrations
    - `pch`: A vector of values designated the point symbols to show in the legend
        - `c(reactantSymbol, productSymbol)`: A vector of values corresponding to the symbols for the reactant and product
    - `col`: A vector of colors to show in the legend
        - `c(reactantColor, productColor)`: A vector of colors corresponding to the symbols for the reactant and product

`r indent()`
The legend is sometimes better located outside the plot region, to be sure there is no chance of confusion or overlap with the plotted data.
Recall that the coordinate system spreads over the whole canvas, not just within the plot region.
Therefore, relocating the legend by changing the `x` and `xjust` argument to be outside the plot region on the right is no problem, remembering that we need to consider the 4% buffer space at the edge of the plot.
We also need to remember to add space in the margin on the right to accommodate the width of the legend.

`r indent()`
One remaining change is critical to ensuring the legend will be visible.
The `xpd` parameter or argument is usually set to `FALSE` by default, which results in anything plotted outside the x and y coordinates of the plotting region to be clipped. Here is the current setting for the default device in this Rmarkdown compiler.

```{r}

par("xpd")

```

This feature is useful because you typically do not want any data outside of the plot region to clutter your margins.
In other words, if you have configured your coordinate system to purposefully disregard data, you do not want the disregarded data to show up in your margins.
Therefore, we need to override the default value for `xpd` and make sure it is set to `TRUE` when purposefully placing the legend in the margins.
Many functions like `plot.xy()`, `text()`, and `legend()` are primarily designed to add symbols to the plot region, and the `xpd` parameter or argument will need to be set to `TRUE` if the symbols they generate outside the plot region need to be visible.
Functions like `mtext()` are designed to add symbols in the margins and do not require this consideration.
Let's remind ourselves of the details of plot construction by using only low level functions for this example.

```{r labelGraph_legendMargin}

# Define chemical reaction data
react <- data.frame(t = seq.default(from = 0, to = 10, by = 1))
react$C <- 5 * exp(-0.5 * react$t)
react$P <- 4 + 0.5 * (5 - react$C)

# Determine the limits of the data
xmin <- min(react$t)
xmax <- max(react$t)
ymin <- min(react$C, react$P)
ymax <- max(react$C, react$P)

# Define the symbols and colors for the plots
reactantSymbol <- 1
reactantColor <- "black"
productSymbol <- 2
productColor <- "darkorange"

# Reset the inner margins (in inches)
par(mai = c(1.02, 0.92, 0.25, 1.2))

# Initialize a new canvas
plot.new()

# Define the coordinate system
plot.window(
  xlim = c(xmin, xmax),
  ylim = c(ymin, ymax)
)

# Add scales to the x and y axes
axis(side = 1)
axis(side = 2)

# Draw a box around the plot region
box()

# Plot the reactant data
plot.xy(
  xy = xy.coords(x = react$t, y = react$C),
  type = "p",
  pch = reactantSymbol,
  col = reactantColor
)

# Plot a product data
plot.xy(
  xy = xy.coords(x = react$t, y = react$P),
  type = "p",
  pch = productSymbol,
  col = productColor
)

# Label the axes
title(
  xlab = "Time (min)",
  ylab = expression(Concentration ~ "(" * mmol ~ L^-1 * ")")
)

# Add the equation to the figure
text(
  x = 3,
  y = 2,
  labels = expression(italic(C == 5 * e^{-0.5 * t})),
  adj = 0,
  col = reactantColor
)

# Add a legend
legend(
  x = xmax + 0.05 * (xmax - xmin),
  y = 0.5 * (ymax - ymin),
  bty = "n",
  xjust = 0,
  yjust = 0.5,
  legend = c("Reactant", "Product"),
  pch = c(reactantSymbol, productSymbol),
  col = c(reactantColor, productColor),
  xpd = TRUE
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

*Functions and arguments being used for the first time*

- `legend()`: Add a legend to a graph at a location based on the coordinate system established by `plot.window()`
    - `x`: Position of the legend relative to the x axis
        -`xmax + 0.05 * (xmax - xmin)`: Use the values calculated for `xlim` to put the legend just outside the right side of the plot region
    - `y`: Position of the legend relative to the y axis
        -`0.5 * (ymax - ymin)`: Use the values calculated for `ylim` to put the legend halfway up the right side of the plot region
    - `xjust`: Justification of the legend relative to the x coordinate provided
        - `0`: Places the legend fully to the right of the x coordinate provided
    - `yjust`: Justification of the legend relative to the y coordinate provided
        - `0.5`: Places the legend centered on the y coordinate provided
    - `xpd` : Switch to disable rendering (`FALSE`, default value) or enable rendering (`TRUE`) of plot region graphics functions like `plot.xy`, `text`, or `legend` in the margins outside the plot region
        - `TRUE`: Enable rendering in the margin so the legend outside the plot region is visible
    