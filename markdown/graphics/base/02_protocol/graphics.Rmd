---
title: "A deeper dive into graphing in base R"
---

Compiled on `r format(Sys.time(), format = "%e %B %Y %H:%M")`.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
sec1 = 0
```

Typical tutorials on graphing in R aim to rapidly develop understanding of higher level graphing functions to get users generating useful graphs quickly. While this approach has merit in certain use cases, it tends to gloss over the lower level understanding of detail on how high level graphing functions work. This lack of detail limits the creativity with which a user is able to create graphs not supported by the higher level functions or the specificity with which a user can make a graphical rendering look exactly as desired. Lack of detail also limits the skill with which a user can troubleshoot graphing code that does not render as expected.

This tutorial is designed to provide a deeper dive into graphing with base R functions. It first reviews the basics of graphics devices, then progresses to build scaffolding of examples with increasing levels of detail into how graphing is implemented in base R. While the tutorial attempts to build in complexity and detail one step at a time, some familiarity with the manipulation of fundamental data types and the operation of functions in R is probably necessary to take full advantage of this tutorial. Completing a higher level tutorial on graphing in base R before working through this more detailed tutorial may be an effective strategy.

The reader should also be prepared to experiment with an open session in R (perhaps starting with code copied from this document) to take full advantage of the tutorial. An effective way to self-assess understanding of the principles in this document is to challenge yourself to predict what a function will do if you change an argument, and then testing that prediction with your own code. Ongoing learning of the R functions that allow exploration of the data structures of arguments to R functions and the return values from R functions is highly recommended for rapid progress in R programming and debugging skill.

This tutorial focuses on graphics tools typically loaded by default in an R session, including the **grDevices** package and the **graphics** package. Not covered here are a family of tools based on the  **grid** graphics package that is an alternative implementation of the **graphics** package and thus provides an alternative interface to creating graphical objects. Popular higher level graphing tools that use **grid** include the **lattice** and **ggplot2** packages. A full understanding of **grid** with the conveniences of **lattice** or **ggplot2** are another way to take full control over the appearance of complex data visualizations. All of these packages use the same rendering tools provided by **grDevices**, so graphics generated from any of them can be combined on the same canvas.

```{r include = FALSE}
sec1 <- sec1 + 1
sec2 <- 0

hn <- paste0(sec1)
```
# `r hn`. Graphics devices

Opening a graphics device creates a blank canvas upon which graphs will be rendered. The most common graphing tools in R (including base R, grid, and ggplot) all use the same canvas provided by a given graphics device. Therefore, if you understand the details of how to control the specific areas of the canvas that are used by a given graphing tool, you can combine or overlap the results of any or all of these tools on the same canvas.

Graphics devices are designed to have a common interface for the functions used to add symbols to the graphs. Ideally, calling a given graphing function should create the same rendered visualization regardless of which device is in use. This feature provides the modularity that a given block of graphing code should create the same image regardless of using a device that renders it on the screen, renders it to a raster image file, or renders it to a vector graphics format. This degree of modularity is seldom fully realized. Particular devices may not have all the features necessary to render all aspects of a given graphing tool. For example, identical fonts or font sizes may not be available across all graphics devices, and transparency in colors will not render properly on all devices. You should expect differences between how different devices plot the same graph, so early consideration of the appropriate device that generates the proper format for the final product is encouraged.

A default device (called the "null device") is likely automatically open in R, where the device used as default depends upon the platform you are using for development. In RStudio, the default device typically renders to the "Plots" tab, which is available in the bottom right panel in a default installation. The device that renders to the "Plots" tab is convenient, but the size and aspect ratio of graphs rendered in this panel will change depending on how your RStudio window is configured. This lack of consistency in size and aspect ratio is problematic when refining figures or sharing code that generates figures, and use of an external device that allows consistency through programmatic control over the dimensions of the figure is suggested.

Let's try graphing on your default device. First, we need a theoretical data set to visualize. Exponential decay, or the processing of something as a constant fraction of the current amount, is a pattern we see everywhere in nature. If we can watch the concentration of a reactant while a chemical reaction is occurring, we might see the concentration ($C$) of a reactant decrease exponentially with time ($t$). For those familiar with chemistry, this pattern would support first-order rate limitation of the reaction. Let's say we are watching a chemical reactor over a 10 minute time period, and we are able to check the concentration every minute.

```{r}

time <- seq.default(from = 0, to = 10, by = 1)

```

Description of functions and arguments being used for the first time:

- ` seq.default() `: Creates a sequence of values 
    - ` from `: The starting value of the sequence
        - ` 0 ` : The first value of the sequence should be 0
    - ` to `: The end of the sequence should be less than or equal to this value
        - ` 10 ` : End the sequence at less than or equal to ten 
    - ` by `: The distance between consecutive elements of the sequence
        - ` 1 ` : Increment each element of the sequence by 1

This results in an atomic numerical vector of values from 0 to 10.

```{r}

print(time)

```

Description of functions and arguments being used for the first time:

- ` print() `: Prints a summary of the content of a variable to the output. In this case, the output ends up in the compiled Rmarkdown report. When using R from the console, the output is printed to the console. Typing a variable name in the console and hitting enter has the same effect as calling `print()` on that variable.

If the reaction is continuously consuming the reactant at a rate of half of the concentration per minute, then we expect the following exponential decay function to describe the change in concentration after some initial value $C_0$.

$$
C = C_0 e^{-0.5 t}
$$
We can use this equation to calculate the concentration of the reactant at each of the times in the vector created earlier. Let's assume the initial concentration is $5 \ \mathrm{mmol \ L^{-1}}$.

```{r}

conc <- 5 * exp(-0.5 * time)

```

This results in an atomic numerical vector the same length as `time`, where each element contains the calculation of the concentration derived from the corresponding element of `time`. 

```{r}

print(conc)

```

A common data structure for keeping data sets together in R is the data frame. For example, we might want to keep the times and the concentrations at those times together.

```{r}

react <- data.frame(t = time, C = conc)

```

Description of functions and arguments being used for the first time:

- ` data.frame() `: Creates a data frame
    - ` t = time `: Creates the first column named `t` based on the values in the vector `time`
    - ` C = conc `: Creates the second column named `C` based on the values in the vector `conc`
    
The result is a table of values where the columns are named `t` and `C` and the rows contain values for each of these variable that correspond to a given sampling time. Note that you will get an error if you try to combine vectors of unequal length into a data frame.

```{r}

print(react)

```

Among other indexing techniques, the `$` operator can be used to retrieve the original vectors composing the columns of a data frame.

The time vector that constitutes the first column...

```{r}

print(react$t)

```

The concentration vector that constitutes the second column...

```{r}

print(react$C)

```

We are ready to plot the data! The `plot()` function is a convenience function that can take care of many details for us. The default device for plotting in Rmarkdown will allow the figure to be rendered in the report immediately after the code chunk with the call to the `plot()` function. Let's plot concentration over time from our chemical reactor.

```{r}

plot(x = react$t, y = react$C)

```

Description of functions and arguments being used for the first time:

- ` plot() `: A convenience function for creating a default plot very quickly
    - ` x `: The vector of values specifying the values for data points on the abscissa axis (a.k.a. the x axis)
    - ` y `: The vector of values specifying the values for data points on the on the ordinate axis (a.k.a. the y axis)

If we put it all together, you should be able to paste the following code in your R script or console and generate the same graph using the default device in your R environment. Note that the columns of the data frame are being constructed directly in this code, without the incremental construction of the `time` and `conc` variables. This code demonstrates how the `$` operator can also be used to create a new column in a data frame.

```
react <- data.frame(t = seq.default(from = 0, to = 10, by = 1))
react$C <- 5 * exp(-0.5 * react$t)
plot(x = react$t, y = react$C)
```

When making meaningful graphs, you will likely quickly reach a point where you want more flexibility or automation than the features offered by the default graphics device. For example, the default device may have an aspect ratio that depends on how the window is currently configured. When making publication-ready graphs, you will typically want direct control over that aspect ratio, or the sizing of the figure in general. Fortunately, the default device can be replaced by calling functions from the `grDevices` package that will render the graphics elsewhere. Let's review a few of these options.

```{r include = FALSE}
sec2 <- sec2 + 1

hn <- paste0(sec1, ".", sec2)
```
## `r hn`. Rendering graphs directly to a new window

Graphics devices launched by calling the `windows()` or `quartz()` functions will render to a new pop-up window on your operating system desktop. A different device is needed for Windows or Mac computers because the nature of desktop windows are different depending on your operating system. The ` windows() ` function will open a pop-up graphics device on a PC, and the ` quartz() ` function will open a pop-up graphics device on a Mac. These devices cannot be demonstrated in an Rmarkdown report, so use the following code as a basis for experimentation. While it may not be necessary in your environment, the `graphics.off()` function is being used here to be sure that any other graphics devices have been closed (other than the default). Note the width, height, and font size for the graphics canvas are specified as arguments to the device functions here to demonstrate the control you gain with using a device other than the default.

For a PC:

``` 
# Shut down any existing devices
graphics.off()

# Open the windows graphics device 
windows(
  width = 6,
  height = 5,
  pointsize = 12
)

# Plot exponential decay data
react <- data.frame(t = seq.default(from = 0, to = 10, by = 1))
react$C <- 5 * exp(-0.5 * react$t)
plot(x = react$t, y = react$C)
```

For a Mac:

``` 
# Shut down any existing devices
graphics.off()

# Open the quartz graphics device 
quartz(
  width = 6,
  height = 5,
  pointsize = 12
)

# Plot exponential decay data
react <- data.frame(t = seq.default(from = 0, to = 10, by = 1))
react$C <- 5 * exp(-0.5 * react$t)
plot(x = react$t, y = react$C)
```

Description of functions and arguments being used for the first time:

- ` graphics.off() `: Close any graphics devices that are currently open (except the default)
- ` windows() ` for a PC or ` quartz() ` for a Mac: Opens a graphics device that writes to a pop-up window in the Windows operating system
    - ` width `: Width of the canvas where graphical elements can be added
        - ` 6 `: Width of the canvas will be 6 inches
    - ` height `: Height of the canvas where graphical elements can be added
        - ` 5 `: Height of the canvas will b 5 inches
    - ` pointsize `: The default point size of characters and symbols
        - ` 12 `: Rendering device will use a 12 point font for characters (12/72 = 1/6 of an inch). You might note from the documentation that 12 is the default value for this argument. Therefore, the same result would be obtained if this argument were removed from the function call.


```{r include = FALSE}
sec2 <- sec2 + 1

hn <- paste0(sec1, ".", sec2)
```
## `r hn`. Rendering graphs to vector or raster files

You might want to render a graph directly to a file to send to a colleague or include in another report. There are multiple devices available in `grDevices` that allow direct generation of industry standard graphics data files.

The device opened by the `pdf()` function renders graphics to a file in vectorized postscript format (e.g., Adobe PDF files), and works on both Mac and PC computing platforms (as well as many others). Key arguments to the function allow specifying the path to the file to be generated, as well as direct control over the basic size and default font point size for a given canvas. As with many devices that create files, this device requires the `dev.off()` function to be called before the graphics file is written. Another program will not be able to open the file being created until `dev.off()` is called to shut down the device.

Calls to `graphics.off()` may be particularly useful when debugging graphing code that is creating files. Calling this function before starting a new graph will make sure that no artifact graphics devices have been left open due to a fatal error in a previous execution of a script. For devices that write to a file, previously opened devices writing to the same file name will likely cause this code to fail because the file cannot be overwritten if it is currently open.

The following code generates a sample PDF file when run in an R session with the working directory set to where the file should be written. You are encouraged to cut and paste this code into an R script, and experiment with running the script with different values for the arguments to confirm you understand the behaviors they control. Note that the script may not run properly if you have the resulting graphics file open in a separate PDF viewer, if that PDF viewer locks the file while it is open. SumatraPDF is a useful PDF viewer for development in Windows because it does not lock the file and automatically updates your view of the PDF file when it is rewritten by your R script.

``` 
# Shut down any existing devices
graphics.off()

# Open the PDF graphics device 
pdf(
  file = "./graphics_test.pdf",
  width = 6,
  height = 5,
  pointsize = 12
)

# Plot exponential decay data
react <- data.frame(t = seq.default(from = 0, to = 10, by = 1))
react$C <- 5 * exp(-0.5 * react$t)
plot(x = react$t, y = react$C)

# Terminate the graphics device
dev.off()
```
Description of functions and arguments being used for the first time:

- ` pdf() `: Opens a graphics device that writes to a postscript file
    - ` file `: Path to the file where the graphics will be written
        - ` "./graphics_test.pdf" `: Results in the vector graphics postscript file "graphics_test.pdf" being written to the working directory.
    - ` width `: Width of the canvas where graphical elements can be added
        - ` 6 `: Width of the canvas will be 6 inches
    - ` height `: Height of the canvas where graphical elements can be added
        - ` 5 `: Height of the canvas will b 5 inches
    - ` pointsize `: The default point size of characters and symbols
        - ` 12 `: Rendering device will use a 12 point font for characters (12/72 = 1/6 of an inch). You might note from the documentation that 12 is the default value for this argument. Therefore, the same result would be obtained if this argument were removed from the function call.
- ` dev.off() `: Closes the most recently opened graphics device. For devices that write to a file (like ` pdf() `). This typically needs to be called for the file to be written to the disk and available to be opened by other applications.

If you are a Windows user, you may want to look into another vectorized graphics device opened by the `win.metafile()` function. This device allows creation of vectorized graphics in Microsoft "enhanced metafile" format. Graphics in this format can either be written to a file or written directly to your Windows clipboard to be pasted into other documents (e.g., MS Word or MS PowerPoint files).

The `grDevices` package provides many options for generating raster image files. For example, `jpg()` allows creation of image files in a compressed raster format that is very commonly used for pictures embedded in web pages. Devices for raster files usually allow some way to control the quality of the image (a compromise with file size) by allowing specification of the pixel resolution.

``` 
# Shut down any existing devices
graphics.off()

# Open the JPG graphics device 
jpeg(
  file = "./graphics_test.jpg",
  width = 6,
  height = 5,
  pointsize = 12,
  units = "in",
  res = 600
)

# Plot exponential decay data
react <- data.frame(t = seq.default(from = 0, to = 10, by = 1))
react$C <- 5 * exp(-0.5 * react$t)
plot(x = react$t, y = react$C)

# Terminate the graphics device
dev.off()
```
Description of functions and arguments being used for the first time:

- ` jpeg() `: Opens a graphics device that writes to a postscript file
    - ` file `: Path to the file where the graphics will be written
        - ` "./graphics_test.jpg" `: Results in the compressed raster graphics file "graphics_test.jpg" being written to the working directory.
    - ` width `: Width of the canvas where graphical elements can be added
        - ` 6 `: Width of the canvas will be 6 inches (as indicated by `units` argument)
    - ` height `: Height of the canvas where graphical elements can be added
        - ` 5 `: Height of the canvas will b 5 inches (as indicated by `units` argument)
    - ` pointsize `: The default point size of characters and symbols
        - ` 12 `: Rendering device will use a 12 point font for characters (12/72 = 1/6 of an inch). You might note from the documentation that 12 is the default value for this argument. Therefore, the same result would be obtained if this argument were removed from the function call.
    - ` units `: Units for the width and height arguments
        - ` "in" `: Units of inches are used for width and height
    - ` res `: Resolution in pixels per inch
        - ` 600 `: A fairly high resolution of 600 pixels per inch for a high quality image. The size of the file generated is highly sensitive to the resolution selected.

Functions to open devices for other raster formats include `bmp()`, `png()`, and `tiff()`.


```{r include = FALSE}
sec2 <- sec2 + 1

hn <- paste0(sec1, ".", sec2)
```
## `r hn`. Graphing in Rmarkdown

When Rmarkdown is being compiled to an html file, the default graphics device used by code chunks embedded in the markdown is `png()`. This device creates a lossless portable graphics format raster file that can be embedded in the html and later displayed by a web browser application when viewing the file. The graphics device is open by default, so an image can be embedded in a compiled Rmarkdown report without opening a device. However, chunk options can be changed to allow graphics device arguments to be altered from their default values. For example, the code chunk generating the graph below sets new values for three chunk options that result in a customized canvas for the associated graphics device. Code chunk options are set by including a list of key-value pairs after the r in the curly brackets specifying the beginning of the chunk.

```
 {r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}
```

Description of Rmarkdown chunk options being used for the first time:

- ` fig.width `: Width of the canvas where graphical elements can be added
    - ` 6 `: Width of the canvas will be 6 inches
- ` fig.height `: Height of the canvas where graphical elements can be added
    - ` 5 `: Width of the canvas will be 6 inches
- ` dev.args `: List of arguments to be passed to the device
    - ` list(pointsize = 12) `: The pointsize argument will be passed to the rendering device, resulting in use of a 12 point font for characters (12/72 = 1/6 of an inch)
    
The following code chunk provides an example of the use of these chunk options to specify the properties of the canvas created by the default ` png() ` device. The edges of the full canvas are delineated using a call to the `box()` graphics function. Note the resulting graph appears immediately following the code chunk.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Plot exponential decay data
react <- data.frame(t = seq.default(from = 0, to = 10, by = 1))
react$C <- 5 * exp(-0.5 * react$t)
plot(x = react$t, y = react$C)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

Description of functions and arguments being used for the first time:

- ` box() `: Draws a box around predefined regions of a graphing canvas
    - ` which `: Specifies which region of the graphing canvas around which to draw the box
        - ` "outer" `: Results in a box around the outer edge of the canvas


**Note to RStudio users:** The device used by RStudio to show graphics within the coding window is not the same device used to generate the compiled document. Be sure to view figures in the final compilation to verify they have the desired characteristics, and do not assume the test figures in the coding window will necessarily match the final figure.

Another device can be opened in a code chunk if the goal is to create a file rather than embed an image in the report. Perhaps the goal is to generate a raster image of the graph independently of the compiled report. For example, we can create a jpg file in a code chunk as demonstrated above, and put that file among the materials associated with this document. Note that the `results = 'hide'` chunk option is set for this chunk to prevent the message returned by `dev.off()` from appearing in the report.

```{r results = 'hide'}

imagePath <- "./03_incremental/images/rmarkdown_example.jpg"

# Open the JPG graphics device 
jpeg(
  file = imagePath,
  width = 6,
  height = 5,
  pointsize = 12,
  units = "in",
  res = 600
)

# Plot exponential decay data
react <- data.frame(t = seq.default(from = 0, to = 10, by = 1))
react$C <- 5 * exp(-0.5 * react$t)
plot(x = react$t, y = react$C)

# Draw a box around the outer edge of the canvas
box(which = "outer")

# Terminate the graphics device
dev.off()

```

No graphics were embedded in the report immediately following this code chunk, because this code is no longer using the default device for the chunk that would result in that behavior. However, we can embed the image we created into the markdown using the following code chunk and the `include_graphics()` function from the knitr package.

The function `normalizePath` here is used to change the relative path into the absolute path. The treatment of the working directory by the `knitr` package can be inconsistent. Using the normalized path for the current machine and forcing `knitr` to work with absolute paths will prevent improper assumptions about the relationship between the working directory and the location of the Rmarkdown file.

```{r}

imagePathNormalized = normalizePath(path = imagePath)
knitr::include_graphics(imagePathNormalized, rel_path = FALSE)

```

Description of functions and arguments being used for the first time:

- ` normalizePath() `: Creates an absolute path to a file on the computer running the R code based on relative path provided.
    - ` path `: The relative path to a file to be converted into an absolute path
        - ` imagePath `: The relative path to the image file created by the previous chunk.
- ` include_graphics() ` from the package ` knitr `: Embeds an image from a file into the compiled Rmarkdown report
    - ` path `: The path to the file containing the image
        - ` imagePathNormalized `: the absolute path to the file from the previous function call
    - ` rel_path `: A switch for using relative paths
        - ` FALSE `: Forces absolute paths to be used

Note that the default scaling for an embedded image is to expand to the full width of the report. Chunk options like `out.width` and `fig.align` can be changed to control this behavior.

```{r include = FALSE}
sec1 <- sec1 + 1
sec2 <- 0

hn <- paste0(sec1)
```
# `r hn`. Dissecting the `plot()` function

Taking full control over your figures requires a deeper understanding of what is happening when high-level functions like `plot()` are used. Specifically, you need to understand how S3 objects work in R, and thus why `plot.default()` is the function that actually gets called when you call `plot()` with a numeric vector for the `x` argument. Subsequently, understanding how `plot.default()` works requires understanding how the device canvas is scaled and how individual graphical elements are added to the canvas by lower level graphing functions. 


```{r include = FALSE}
sec2 <- sec2 + 1

hn <- paste0(sec1, ".", sec2)
```
## `r hn`. Why is `plot.default()` called when I call `plot()`? (S3 objects in R)

One way to explore the S3 abstraction for `plot()` is to look at the implementation of the function. For functions implemented with R code, the implementation of the function can be viewed by typing the function name at the console prompt, without parentheses.

``` {r}

plot

```

The entire implementation of this function is simply a call to the `UseMethod()` function, which means that the function that ultimately gets called depends on the data type of the first argument to the `plot(x, y, ...)` function. In other words, a call to `plot` is not enough information to know what is going to happen, you also need to know the data type of the first argument to `plot(x, y, ...)`. This abstraction is an artifact of the S3 implementation of object oriented programming, and is the reason why calling `help("plot", package = "base")` yields so little specific information about the arguments that can be used. Calls to `plot()` are abstract and do not provide enough information to know what arguments will be valid.

For the purposes of this document, calls to `plot()` will always pass an atomic vector to the first argument `x`, which results in the `plot.default()` function being called by `UseMethod()`. Any arguments passed to `plot()` are also passed on to `plot.default()`. Note that the implementation of `plot.default()` contains the far more complex code that is actually creating the components of the figure. For further exploration, note that calling `help("plot.default")` also yields far more detailed information about how to use the `plot()` function on vector arguments than `help("plot", package = "base")`. 

``` {r}

plot.default

```

For other examples of S3 functional abstractions, look at the implementation of the `print()` or `summary()` functions. See if you can find the specific implementations of these functions for particular data types that might be passed as the first argument to the abstraction (e.g., `print.default()` or `print.data.frame()`) . While detailed knowledge of the benefits of these object-oriented principles of polymorphic classes is not strictly necessary to use R, deeper understanding of this topic will allow for more informed troubleshooting when a function does something unexpected. If nothing else, deeper understanding of S3 abstractions will provide a pathway to finding more detailed documentation with `help()` on the functions you are actually using when calling abstract methods.


```{r include = FALSE}
sec2 <- sec2 + 1

hn <- paste0(sec1, ".", sec2)
```
## `r hn`. Scaling the canvas

The coordinate system for the canvas must be defined before `plot.default()` can place any symbols on the canvas at desired locations. The coordinate system is established by first calling `plot.new()` to prepare the canvas for a new plot. Then, a call to `plot.window()` establishes the coordinate system.

Scaling of the canvas is based on vectors passed to `xlim` and `ylim` arguments that define the coordinates associated with the boundaries of a rectangular plot region on the canvas (i.e. the area of the canvas where data is intended to be plotted). The effect of these functions can be explored by calling them directly with simplified arguments, consistent with examples provided above. Here, a box is drawn around the plot region and the outer edge of the canvas to aid with visualization of the basis for the coordinate system, though symbolism is not yet provided for visualization of the coordinate system numerics (see later materials on the ` Axis() ` function). The size of the margins around the plot region are defined by default graphic parameters that will be discussed in detail, later (e.g., see later materials introducing ` par("mar") `). As above, the Rmarkdown code chunk options are set to control the dimensions of the canvas being embedded in the compiled document, and all code chunks in the remainder of this section are configured the same way.

```
 {r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}
```

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Create exponential decay data
react <- data.frame(t = seq.default(from = 0, to = 10, by = 1))
react$C <- 5 * exp(-0.5 * react$t)

# Determine the limits of the data
xmin <- min(react$t)
xmax <- max(react$t)
ymin <- min(react$C)
ymax <- max(react$C)

# Initialize a new canvas
plot.new()

# Scale the canvas 
plot.window(
  xlim = c(xmin, xmax),
  ylim = c(ymin, ymax)
)

# Draw a box around the plot region
box()

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

Description of functions and arguments being used for the first time:

- ` plot.new() `: Prepares the device canvas for a new plot
- ` plot.window() `: Scales the canvas, providing an orthogonal 2-dimensional coordinate system (x is horizontal and y is vertical) for locating graphical objects placed on the canvas by later calls to graphing functions.
    - ` xlim `: Numerical vector with 2 elements specifying the leftmost and rightmost values to be used in the graphing area of the coordinate system
    - ` ylim `: Numerical vector with 2 elements specifying the bottommost and topmost values to be used in the graphing area of the coordinate system
- ` box() `: Draws a box around predefined regions of a graphing canvas
    - No arguments implies the default ` which = "plot" `, which results in a box drawn around the plot region.

The results are not particularly exciting. The fact that we have established a coordinate system does not result in any graphical elements being added to the canvas. The boxes aiding in visualization had to be added manually. However, this code has provided a spatially rectified blank slate, such that there is now a context for adding graphical elements at the exact coordinates desired.


## `r sec1`.`r sec2 <- sec2 + 1; sec2`. Plotting the data

Graphics objects can now be added to the canvas in layers. Lower layers will still be visible, unless opaque elements are added on top of them. The ` plot.default() ` function plots the data as the first visible element of the figure, using the function ` plot.xy() `. The first argument (` xy `) is expected to be a list of vectors characterizing the coordinates to be plotted. This list can be conveniently constructed using the ` xy.coords() ` function with arguments specifying the x and y coordinates for a number of points to be plotted. The points plotted here are at coordinates 0, 0 and 1, 1. Multiple arguments are available to adjust the symbolism of each data point, but symbols will be black open circles if those arguments are not specified.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Initialize a new canvas
plot.new()

# Scale the canvas 
plot.window(
  xlim = c(0, 1),
  ylim = c(0, 1)
)

# Draw a box around the plot region
box()

# Draw a box around the outer edge of the canvas
box(which = "outer")

# Plot example data points
plot.xy(
  xy = xy.coords(
    x = c(0, 1),
    y = c(0, 1)
  ),
  type = "p"
)

```

Description of functions and arguments being used for the first time:

- ` plot.xy() `: Renders the symbolism of a bivariate scatter plot on the canvas
    - ` xy `: An coordinate list specifying information about the x an y coordinates of a set of data to be plotted.
        - ` xy.coords(...) `: A function returning the list of x and y coordinates for the data set to be plotted (see below)
    - ` type `: The character string code for the type of scatter plot to render
        - ` "p" `: Results in data being plotted as point symbols in the scatter plot
- ` xy.coords() `: Creates a coordinate list for a bivariate data set to be plotted
    - ` x `: Numerical vector of values for the x coordinate of each data point graphed
        - ` c(0, 1) `: Two data points with x coordinates of 0 and 1, respectively.
    - ` y `: Numerical vector of values for the y coordinate of each data point graphed
        - ` c(0, 1) `: Two data points with y coordinates of 0 and 1, respectively.

The result is two points on the graph, exactly as would be expected by two points plotted within the domain defined in ` plot.window() `. The box around the plot region provides a hint of the layout of the coordinate system in relation to the plotted values at x = 0, y = 0 and x = 1, y = 1, but further numeric symbolism around the plot region is required to directly read values from the graph.


## `r sec1`.`r sec2 <- sec2 + 1; sec2`. Creating the axes

The ` Axis() ` function provides a tool for adding axes describing the scale of the canvas in the area where the data are being plotted. This function is highly configurable to make an axis with ticks and labels exactly where desired, but the default arguments will attempt to create ticks and labels that are reasonably legible. Here, the only argument provided is the side of the graph where the axis should be located (1 is the bottom and 2 is the left). Note that the box around the plot region has been omitted to provide a clear view of the symbolism generated by the ` Axis() ` function.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Initialize a new canvas
plot.new()

# Scale the canvas 
plot.window(
  xlim = c(0, 1),
  ylim = c(0, 1)
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

# Plot example data points
plot.xy(
  xy = xy.coords(
    x = c(0, 1),
    y = c(0, 1)
  ),
  type = "p"
)

# Add an x axis
Axis(side = 1)

# Add a y axis
Axis(side = 2)

```

Description of functions and arguments being used for the first time:

- ` Axis() `: Renders the symbolism of an axis with labeled ticks
    - ` side `: An integer specifying the side of the plotting area upon which to place the axis (1 = bottom, 2 = left, 3 = top, 4 = right)
        - ` 1 ` or ` 2 `: Call with 1 creates the x axis and call with 2 creates the y axis

The axes clearly label the scaling of the canvas in the plot region, where an automated algorithm has determined aesthetically pleasing tick intervals and tick labels. The consistency of the scaling established by ` plot.window() ` is now evident, in that the data points plotted earlier line up with the appropriate ticks on the axes. These are the fundamentals of building any graph on the canvas.


## `r sec1`.`r sec2 <- sec2 + 1; sec2`. Labeling the axes

The ` title() ` function is a unified tool for labeling different parts of the graph. Most style guides for figures suggest that the area where data are plotted should be differentiated from the rest of the figure. The ` box() ` function with no arguments is reintroduced here to clearly delineate the plot region from the rest of the canvas. The box overlaps with the axes lines, such that the axes are effectively only providing the ticks and tick labels. As with previous graphics tools, the location and symbolism used for the elements being added are highly configurable with additional arguments. However, the default arguments are used for now, and detail on arguments that are commonly altered from the defaults are discussed later.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Initialize a new canvas
plot.new()

# Scale the canvas 
plot.window(
  xlim = c(0, 1),
  ylim = c(0, 1)
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

# Plot example data points
plot.xy(
  xy = xy.coords(
    x = c(0, 1),
    y = c(0, 1)
  ),
  type = "p"
)

# Add an x axis
Axis(side = 1)

# Add a y axis
Axis(side = 2)

# Draw a box around the plot region
box()

# Add axis labels
title(
  xlab = "x",
  ylab = "y"
)

```

Description of functions and arguments being used for the first time:

- ` title() `: Renders the symbolism of labels on various elements of a graphing canvas
    - ` xlab `: A character string (or expression) specifying the label for the x axis
        - ` "x" `: Results in the x axis being labeled with an "x"
    - ` ylab `: A character string (or expression) specifying the label for the y axis
        - ` "y" `: Results in the y axis being labeled with a "y"


## `r sec1`.`r sec2 <- sec2 + 1; sec2`. Summary

This dissection of `plot.default() ` clearly requires substantially more lines of code than the original example of a single call to ` plot() ` that generates exactly the same figure. The point here is not that you should avoid using ` plot() ` and subsequently ` plot.default() `, because it clearly provides substantial convenience for basic plotting. The point is that your ability to debug and be creative with graphing code will expand if you understand how functions like ` plot.default() ` construct a graph, such that you can take advantage of the power of altering the arguments for each component of the graph should it be necessary to do something ` plot.default() ` does not allow. Furthermore, understanding of these details allows for much more informed troubleshooting should high level functions like ` plot.default() ` produce something unexpected in a given application.


# `r sec1 <- sec1 + 1; sec2 <- 0; sec1`. The default values controlling graphical behavior

A revisit of the code and result for the basic figure introduced earlier reveals that the ` plot() ` function must be making several assumptions about the desired format of the plot. 

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Plot example data points
plot(
  x = c(0, 1),
  xlab = "x",
  y = c(0, 1),
  ylab = "y"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

Note that many aesthetic or technical aspects of this plot did not have to be defined in the code, including (but not limited to): the use of point symbols rather than lines; the shape and color of the points; the thickness of boxes and axes lines; and the location of the axes relative to the edges of the canvas. However, computers are generally not able to guess at what these aspects of plots should look like, so default information about the aesthetic or technical appearance of graphs must exist somewhere in the underlying R data structures. An important trick to full control over figures is to understand where that information is stored, how it is used, and how to change it. Understanding how to query or configure the graphical parameters opens the door to understanding the behavior of both high and low level graphical functions. The combination of arguments passed to these functions and the current value of the global graphical parameters are what allow explicit control over the scaling, formatting, symbolism, and labeling used in base R graphics. In other words, they are the key to knowing how to place any symbol the computer can generate at any desired location on the canvas. 

While working through this section, frequent reference to the base R documentation using ` help("par") ` or calling ` help() ` on the graphing functions is recommended to convince yourself you understand the consequences of using various graphical arguments or changing graphics parameters. As always, experimentation is highly encouraged.


## `r sec1`.`r sec2 <- sec2 + 1; sec3 <- 0; sec2`. Default values for arguments to graphical functions

A common location for default graphical information is the definition of default values for the arguments to graphical functions. For example, the ` plot.default() `function (e.g., what is called if using ` plot() ` on vectors) accepts the optional argument ` type ` that controls the type of symbolism used for the data in the graph. The values that can be passed to ` type ` to control the symbolism are documented in the package containing the function and in this case can be accessed using the  ` help("plot.default") `. The potential values for arguments are usually described in either the **Arguments** section or **Details** section of the function documentation. Any default value defined for a parameter is usually described in the **Usage** or **Arguments** section. A quick and succinct way to view the definition of a function's arguments is to use the ` args() ` function (e.g., ` args(plot.default) `).

```{r}
# Display the definition of arguments 
#   for the function plot.default
args(name = plot.default)
```

Description of functions and arguments being used for the first time:

- ` args() `: Returns the argument definitions for a function. Return type is a function with the argument definition but a NULL code block.
    - ` name `: The name of the function for which the argument definition is retrieved
        - ` plot.default `: Causes the function to return the argument definitions for the function ` plot.default() `

Note that the argument ` type ` is followed by the assignment ` = "p" `, which designates that it will take on the value of the character string ` "p" ` if a value for that argument is not provided in a given call to the function. Any differing value provided for ` type ` in a call to the function will replace the default value and thus change the symbolism in the plot. For example, passing the value ` "o" ` to the argument ` type ` will result in an overlay of both points and lines.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Plot example data points with lines
plot(
  x = c(0, 1),
  xlab = "x",
  y = c(0, 1),
  ylab = "y",
  type = "o"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

Description of functions and arguments being used for the first time:

- ` plot() ` or ` plot.default() `: A high level function for creating a new plot with a single line of code
    - ` type ` : A character string that defines the symbolism used when plotting data. For example, a value of "p" denotes points, "l" denotes lines, and "o" denotes an overlay of points and lines (among others). Note that the argument ` type ` is passed to plot generically here and ultimately this argument is not used specifically until it is passed to the ` plot.xy() ` function by ` plot.default() `.
        - ` "o" `: Results in graphing data as an overlay of points and lines


## `r sec1`.`r sec2 <- sec2 + 1; sec3 <- 0; sec2`. Retrieving and adjusting values of graphical parameters

Extensive information used to plot graphical elements is also stored in a collection of default values for common graphical parameters associated with the open device. The current default values for these graphical parameters can be accessed by passing the names of those parameters as arguments to the ` par() ` function. For example, the graphics parameter that determines the symbols used for data points is ` pch `, so the current value of "pch" can viewed with...

```{r}
# Display the value of the graphical parameter pch 
#   for the current graphics device
par("pch")
```

Description of functions and arguments being used for the first time:

- ` par() `: Allows the values of graphical parameters associated with the current open graphics device to be retrieved or altered. Calling ` par() ` with no arguments will provide the full list of available graphics parameters.
    - ` ... `: The ellipses in the definition of arguments to a function indicate that the function will accept any number of generic arguments when called. "Generic" means that the function will either interpret the comma-delimited generic collection of elements without explicit definition of argument names, or it means that any generic arguments provided will be passed generically to other functions called when the function's code is executed. Use of ellipses in graphical functions is a very common practice for passing values for graphical parameters generically from higher level functions to lower level functions.
        - ` "pch" `: Passing the character string "pch" as a generic argument to ` par() ` results in a return value of the current default value of the correspondingly named graphical parameter. Note that multiple parameter names can be provided in a comma delimited list of character strings, which will return a named list of values with each element providing the current default value for each graphical parameter provided. For example ` par("pch", "lty") ` will return the current default values for the point type and line type graphical parameters.

By default, ` pch ` typically has a value of 1, which specifies an open circle, hence the symbols plotted in the graphs so far have all been open circles. The par function can also be used to change the values of graphical parameters based on a collection of ` <parameter> = <value> `  in the argument to the function call. Thus, the default symbol can be changed to an open triangle by changing the value of the graphics parameter ` pch ` to 2.

```{r}
# Change the value of the graphical parameter pch 
#   for the current graphics device
par(pch = 2)

# Display the value of the graphical parameter pch 
#   for the current graphics device
par("pch")
```

Description of functions and arguments being used for the first time:

- ` par() `: Allows the values of graphical parameters associated with the current open graphics device to be retrieved or altered.
    - ` pch = 2 `: Passing a named value to the generic arguments in ` par() ` will result in the default value for the named graphical parameter to be changed to the provided value. Setting the graphical parameter ` pch ` to 2 will result in data being represented by open triangles.

Changing the value of a graphical parameter with ` par() ` will change the default value within the open graphics device for all subsequent calls to graphical functions, until the device is closed or reset. If we add an additional plot to the basic graph, it will also use the new setting of the graphical parameter ` pch `.

The effect of this change can be demonstrated by calling two different graphing functions that plot data points in sequence. The understanding gained from dissecting the ` plot() ` function provides one method for adding an additional plot to the same basic graph, putting points in the unused corners of the basic graph using the ` plot.xy() ` function.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Change the value of the graphical parameter pch
par(pch = 2)

# Plot example data points
plot(
  x = c(0, 1),
  xlab = "x",
  y = c(0, 1),
  ylab = "y",
  type = "o"
)

# Plot example data points
plot.xy(
  xy = xy.coords(
    x = c(0, 1),
    y = c(1, 0)
  ),
  type = "p"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

All the data points are open triangles, demonstrating how changing the ` pch ` graphical parameter with ` par() ` altered the value for all subsequent calls to graphics functions within the code chunk. Note that in Rmarkdown, each code chunk will open a separate graphics device, such that any changes to graphics parameters applied to the device in one code chunk will not propagate to other code chunks without further action.

The main reason that graphics parameters controlled by ` par() ` have influence with subsequent graphing code is that they often represent the default values for arguments to lower level graphing functions. Therefore, the default values of the graphics parameters can often be locally overridden using values passed directly to those arguments. For example, consider the default value for the ` pch ` parameter in the list of arguments to the ` plot.xy() ` function.

```{r}
args(plot.xy)
```

The default value for the ` pch ` argument comes directly from the graphical parameters via a call to ` par("pch") `. Therefore, the value for the graphing parameter that would normally result in triangle symbols from the previous example can be overridden for the call to ` plot.xy() ` by directly setting a value for the ` pch ` argument.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Change the value of the graphical parameter pch
par(pch = 2)

# Plot example data points
plot(
  x = c(0, 1),
  xlab = "x",
  y = c(0, 1),
  ylab = "y",
  type = "o"
)

# Plot example data points
plot.xy(
  xy = xy.coords(
    x = c(0, 1),
    y = c(1, 0)
  ),
  type = "p",
  pch = 0
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

Description of functions and arguments being used for the first time:

- ` plot.xy() `: Renders the symbolism of a bivariate scatter plot on the canvas
    - ` pch `: A vector of integers or characters specifying the symbol to use for data points.
        - ` 0 `: An integer value of zero specifies an open square symbol
        
In this case, the value of the graphical parameter ` pch ` is ignored in place of the value directly passed to the ` pch ` argument of the ` plot.xy() ` function, hence the squares in the second plot rather than the triangles.


# `r sec1 <- sec1 + 1; sec2 <- 0; sec1`. Scaling the canvas

In base R, the scaling of the coordinate system for a device canvas is defined in the context of a rectangular subset of the canvas designated as a *plot region*. This region defines the area within which symbols representing data are conventionally rendered, though the scale extends across the entirety of the canvas and symbols can technically be plotted anywhere, if desired. The scaling function ` plot.window() ` is responsible for establishing the coordinate system to be used by later calls to graphics functions. Derivation of the coordinate system is based on the margins between the plot region and the edge of the canvas, the limits of the x and y coordinates that define the edges of the plot region, and parameters that control buffering of the symbols within the plot regions from the edges of the plot region. Therefore, taking full control of scaling requires understanding the graphical parameters and function arguments that control the behavior of ` plot.window() ` in performing these derivations.


## `r sec1`.`r sec2 <- sec2 + 1; sec2`. Defining a plot region for a single graph

The location of the plot region is defined by a set of nested outer and inner margins that together dictate the distance between the edges of the canvas and the bottom, left, top, and right edges of the plot region. For now, we will focus on scaling the canvas for a single graph, which means the outer and inner margins are simply additive. In this case, the outer margins are often set to zero (hence their default value) and the inner margins are thus given sole control over the location of the edges of the plot region. See ` help("par") ` and the documentation for graphical parameters ` oma ` / ` omi ` and ` mar ` / ` mai ` for visualizations of the margin structure. We will revisit the utility of nonzero outer margins when discussing multi-panel graphs. 

Depending on units used, the values for the outer margins can be retrieved or set with the graphical parameters ` oma ` or ` omi `, such that we can confirm their default value of zero with the following code.

```{r}
par("oma", "omi")
```

Description of functions and arguments being used for the first time:

- ` par() `: Allows the values of graphical parameters associated with the current open graphics device to be retrieved or altered.
    - ` "oma" ` or ` "omi" `: Returns the current setting for the graphical parameter defining the outer margins. The return value will be a vector with 4 elements designating the bottom, left, top, and right margins, in that order.

With outer margins defaulting to zero, the scaling for the basic plots we have examined so far has been determined exclusively by the inner margins, or the distance from the edges of the plot region to the inside of the outer margin (which is the edge of the canvas when outer margins are set to zero).

```{r}
par("mar", "mai")
```

Description of functions and arguments being used for the first time:

- ` par() `: Allows the values of graphical parameters associated with the current open graphics device to be retrieved or altered.
    - ` "mar" ` or ` "mai" `: Returns the current setting for the graphical parameter defining the default margins for an individual graph. The return value will be a vector with 4 elements designating the bottom, left, top, and right margins, in that order. The parameter ` mar ` is in the relative units of *lines*, which are sized relative to the point size of the font being used in labels in the margin of the graph.  The parameter ` mai ` is in absolute units of inches, which is independent of font size. If either of these parameter values is changed using the ` par() ` function, the other is automatically updated based on the font size being used.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Plot example data points
plot(
  x = c(0, 1),
  xlab = "x",
  y = c(0, 1),
  ylab = "y"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

The extra white space visible at the top and right of this basic plot is thus determined by the default values for the third and fourth elements of ` mar ` or ` mai `. Full control and consistency of the margins and subsequent scaling of the canvas can be gained by setting these graphical parameters explicitly with ` par() ` before using the graphical functions that reference them. For example, we can reduce the extra white space at the top and right sides of the graph by reducing the sizes of the margin defined in the third and fourth elements of ` mai `.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Define margins leaving room for axes on the bottom and left sides
par(
  omi = c(0, 0, 0, 0),
  mai = c(0.9, 0.9, 0.2, 0.2)
)

# Plot example data points
plot(
  x = c(0, 1),
  xlab = "x",
  y = c(0, 1),
  ylab = "y"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

Experiment with values for the margins to be sure you understand their behavior. For example, recognize the potentially confusing behavior that labels might be cut off if the scaling dictates they fall outside the canvas. Understanding behavior of margins will prevent going down the incorrect troubleshooting path of assuming the axis labels are not being generated in the following graph. They are being generated, just outside the canvas that is in view.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Define margins without leaving room for axes labels 
#   on the bottom and left sides
par(
  omi = c(0, 0, 0, 0),
  mai = c(0.6, 0.6, 0.2, 0.2)
)

# Plot example data points
plot(
  x = c(0, 1),
  xlab = "x",
  y = c(0, 1),
  ylab = "y"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

Not that R graphics will not warn you that components of your graph are not visible because they are being plotted outside the limits of the device canvas.


## `r sec1`.`r sec2 <- sec2 + 1; sec2`. Defining a coordinate system for a plot region

Once margins are established, the derivation of the coordinate system for the canvas is subsequently controlled by the limits of the plot regions established by the ` xlim ` and ` ylim ` arguments to ` plot.window() `. Unless otherwise specified, the values of ` xlim ` and ` ylim ` will be determined by the associated minimum and maximum values in the vectors begin plotted. This default behavior will be overridden if explicit values for ` xlim ` and ` ylim ` are somehow passed to ` plot.window() ` when scaling the canvas. For example, passing ` xlim ` and ` ylim ` values to the generic ` plot() ` function will result in these values being passed to ` plot.window() ` via a call to ` plot.default() `.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Define margins leaving room for axes 
#   on the bottom and left sides
par(
  omi = c(0, 0, 0, 0),
  mai = c(0.9, 0.9, 0.2, 0.2)
)

# Plot example data points
plot(
  x = c(0, 1),
  xlim = c(-1, 2),
  xlab = "x",
  y = c(0, 1),
  ylim = c(-1, 2),
  ylab = "y"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

Description of functions and arguments being used for the first time:

- ` plot() ` or ` plot.default() ` : A high level function for creating a new plot with a single line of code. The function ` plot() ` is an S3 abstraction, which in this case results in a call to ` plot.default() `.
    - ` xlim `: Numerical vector with 2 elements specifying the leftmost and rightmost values to be used in the graphing area of the coordinate system
    - ` ylim `: Numerical vector with 2 elements specifying the bottommost and topmost values to be used in the graphing area of the coordinate system

The effect of changing these arguments on scaling the canvas can be demonstrated by altering the call to ` plot.window() ` directly.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Define margins leaving room for axes 
#   on the bottom and left sides
par(
  omi = c(0, 0, 0, 0),
  mai = c(0.9, 0.9, 0.2, 0.2)
)

# Initialize a new canvas
plot.new()

# Scale the canvas 
plot.window(
  xlim = c(-1, 2),
  ylim = c(-1, 2)
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

# Plot example data points
plot.xy(
  xy = xy.coords(
    x = c(0, 1),
    y = c(0, 1)
  ),
  type = "p"
)

# Add an x axis
Axis(side = 1)

# Add a y axis
Axis(side = 2)

# Draw a box around the plot region
box()

# Add axis labels
title(
  xlab = "x",
  ylab = "y"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

Note that order of the magnitude of the limits in either the x or y direction is arbitrary. The example above follows the common convention that values increase in magnitude with movement upward in y space and that values increase in magnitude with movement to the right in x space. Reversing this convention in derived the coordinate system simply requires reversing the definition of the values of the limits associated with the bounds of the plot region. For example, the following will invert the y axis from previous examples by setting the y value associated with the bottom of the plot region to 1 and the y value associated with the top of the plot region to 0.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Define margins leaving room for axes on the
#   bottom and left sides
par(
  omi = c(0, 0, 0, 0),
  mai = c(0.9, 0.9, 0.2, 0.2)
)

# Plot example data points
plot(
  x = c(0, 1),
  xlab = "x",
  y = c(0, 1),
  ylim = c(1, 0),
  ylab = "y"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

The numerical distribution used to represent the coordinate system for either axis can also be altered to a base-10 logarithmic scale. A logarithmic number system can be specified by a passing a value for the ` log ` argument generically to ` plot() ` or directly to ` plot.window() ` where the argument ultimately takes effect. The value for this argument can be the character string "x" or "y" to specify a log scale on only one of the axes, or the character string "xy" to specify a log scale on both axes. For example, the x scaling can be altered to be on a log scale with x coordinate values at 0.1 and 1 as follows (values of zero cannot be plotted in log space).

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Define margins leaving room for axes on the
#   bottom and left sides
par(
  omi = c(0, 0, 0, 0),
  mai = c(0.9, 0.9, 0.2, 0.2)
)

# Plot example data points
plot(
  x = c(0.1, 1),
  xlab = "x",
  y = c(0, 1),
  ylab = "y",
  log = "x"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

Description of functions and arguments being used for the first time:

- ` plot() ` or ` plot.default() `: A high level function for creating a new plot with a single line of code. The function ` plot() ` is an S3 abstraction, which in this case results in a call to ` plot.default() `.
    - ` log `: A character string specifying which axes should be in log space. The value "x" or "y" specifies one of the axes is in log space, and the value of "xy" specifies that both axes are in log space. Note that this argument is passed to ` plot() ` generically, and its effect on scaling is not realized until ` plot.default() ` ultimately passes the value assigned to ` log ` on to ` plot.window() `.
        - ` "x" `: Specifies that the x axis should be scaled in log space


## `r sec1`.`r sec2 <- sec2 + 1; sec2`. Customizing the internal buffers within a plot region

In the basic plot used as a frequent example, note the extra internal space between the edges of the plot region and the minima of 0 and the maxima of 1 defining the default limits of the plot region. 

This default buffering (which is derived from 4% of the difference between the maximum and minimum of the limits) influenced the overall scaling of the canvas and is controlled by the axis type. The axis types are configurable with the ` xaxs ` and ` yaxs ` graphics parameters.

```{r}
par("xaxs", "yaxs")
```

Description of functions and arguments being used for the first time:

- ` par() `: Allows the values of graphical parameters associated with the current open graphics device to be retrieved or altered.
    - ` "xaxs" ` or ` "yaxs" `: Returns the current setting for the graphical parameter defining the type of the x or y axes. By default, values are the character string "r" indicated a "regular" scaling (includes a 4% buffer around the limits of the plot region).

The default types for the axes can be specified generally for the device using the ` par() ` function.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Define margins leaving room for axes on the
#   bottom and left sides
# Set the types of both axes to internal
par(
  omi = c(0, 0, 0, 0),
  mai = c(0.9, 0.9, 0.2, 0.2),
  xaxs = "i",
  yaxs = "i"
)

# Plot example data points
plot(
  x = c(0, 1),
  xlab = "x",
  y = c(0, 1),
  ylab = "y"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

Values for the ` xaxs` and ` yaxs ` arguments can also be passed generically to the ` plot() ` function, which will ultimately pass them on to ` plot.window() ` to achieve the same result. However, this technique will not change the default graphical parameter values, so the effects of using these arguments would not propagate to other graphs created later on the same device.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Define margins leaving room for axes on the
#   bottom and left sides
par(
  omi = c(0, 0, 0, 0),
  mai = c(0.9, 0.9, 0.2, 0.2)
)

# Plot example data points
plot(
  x = c(0, 1),
  xlab = "x",
  xaxs = "i",
  y = c(0, 1),
  ylab = "y",
  yaxs = "i"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

Note that without the buffering, the symbols on this graph are barely visible. Only a quarter of each circle symbol can be seen in the corners of the plot region. The full circles are actually there, the parts of them outside the plot region are just being clipped. This clipping is, yet again, controlled by a graphics parameter (i.e., ` xpd `).

```{r}
par("xpd")
```

Description of functions and arguments being used for the first time:

- ` par() `: Allows the values of graphical parameters associated with the current open graphics device to be retrieved or altered.
    - ` "xpd" `: Returns the current setting for the logical control on whether plot region symbols are rendered when located in the margins. A value of "TRUE" means that symbols in the margins will be visible. A value of "FALSE" means they will not.

This graphics parameter can be altered to allow plot region symbols to be visible if plotted in the margins.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Define margins leaving room for axes on the
#   bottom and left sides
# Allow rendering of plot region symbolism
#   in the margins
par(
  omi = c(0, 0, 0, 0),
  mai = c(0.9, 0.9, 0.2, 0.2),
  xpd = TRUE
)

# Plot example data points
plot(
  x = c(0, 1),
  xlab = "x",
  xaxs = "i",
  y = c(0, 1),
  ylab = "y",
  yaxs = "i"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

As with axis types, a value for the ` xpd ` argument can be generically provided to ` plot() `. This generic argument is subsequently passed to ` plot.xy() `, which has the effect of disabling clipping for the generated plot. However, this does not change the default graphics parameter, so this approach would have no effect on future plotting on the same device.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Define margins leaving room for axes on the
#   bottom and left sides
par(
  omi = c(0, 0, 0, 0),
  mai = c(0.9, 0.9, 0.2, 0.2)
)

# Plot example data points
plot(
  x = c(0, 1),
  xlab = "x",
  xaxs = "i",
  y = c(0, 1),
  ylab = "y",
  yaxs = "i",
  xpd = TRUE
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

While locating the symbols representing data outside the plot region is not typical, this exercise illustrates the effect of the ` xpd ` graphical parameter or argument, which is useful in common labeling tasks like placing legends outside the axes of plots.


## `r sec1`.`r sec2 <- sec2 + 1; sec2`. Summary of scaling a canvas for a single graph

So far, we have been able to gain complete control of scaling while continuing to use the high-level abstract function ` plot() `, which ultimately calls ` plot.default() ` and passes generic arguments on to lower level graphing functions, such as ` plot.window() ` and ` plot.xy() `. Understanding the behavior of these examples comes from recognizing that the resulting plot is being generated by the following sequence of calls to lower level graphical functions. For example, the graph with a logarithmic x axis, with altered margins, without buffers, and with visible symbols in the margins can be properly scaled and created with lower level functions as follows.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Define margins leaving room for axes on the
#   bottom and left sides
par(
  omi = c(0, 0, 0, 0),
  mai = c(0.9, 0.9, 0.2, 0.2)
)

# Initialize a new canvas
plot.new()

# Scale the canvas 
plot.window(
  xlim = c(0.1, 1),
  xaxs = "i",
  ylim = c(0, 1),
  yaxs = "i",
  log = "x"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

# Plot example data points
plot.xy(
  xy = xy.coords(
    x = c(0.1, 1),
    y = c(0, 1)
  ),
  type = "p",
  xpd = TRUE
)

# Add an x axis
Axis(side = 1)

# Add a y axis
Axis(side = 2)

# Draw a box around the plot region
box()

# Add axis labels
title(
  xlab = "x",
  ylab = "y"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

Description of functions and arguments being used for the first time:

- ` plot.window() `: Scales the canvas, providing an orthogonal 2-dimensional coordinate system (x is horizontal and y is vertical) for locating graphical objects placed on the canvas by later calls to graphing functions.
    - ` xaxs ` or ` yaxs `: Character string specifying the type of scaling to use for the x or y axis
        - ` "i" `: An "internal" axis does not include any buffering outside the minima and maxima of the values in the x and y vectors of coordinates
    - ` log `: A character string specifying which axes should be in log space. The value "x" or "y" specifies one of the axes is in log space, and the value of "xy" specifies that both axes are in log space.
        - ` "x" `: Specifies that the x axis should be scaled in log space
- ` plot.xy() `: Renders the symbolism of a bivariate scatter plot on the canvas
    - ` xpd `: A logical value indicating whether plot region symbolism located at canvas coordinates in the margins outside the plot region should be visible (` TRUE `) or clipped (` FALSE `)
        - ` TRUE `: Results in the portions of the data symbols (circles) in the margins outside the plot region to be visible.
        
Just these few scaling features and recognition that the same canvas can be rescaled over and over again shows the way forward to more creative techniques, such as adding data to the plot region on a secondary y axis. Starting with the previous example, we can alter margins to make room for the secondary axis on the right, rescale the canvas using ` plot.window() `, plot the data using ` plot.xy() `, and add the secondary axis to the right side of the plot region using ` Axis() `, without the need to learn any new functions or arguments.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Define margins leaving room for axes on the
#   bottom, left, and right sides
par(
  omi = c(0, 0, 0, 0),
  mai = c(0.9, 0.9, 0.2, 0.9)
)

# Initialize a new canvas
plot.new()

# Scale the canvas 
plot.window(
  xlim = c(0.1, 1),
  xaxs = "i",
  ylim = c(0, 1),
  yaxs = "i",
  log = "x"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

# Plot example data points
plot.xy(
  xy = xy.coords(
    x = c(0.1, 1),
    y = c(0, 1)
  ),
  type = "p",
  xpd = TRUE
)

# Add an x axis
Axis(side = 1)

# Add a y axis
Axis(side = 2)

# Rescale the canvas for a secondary axis
plot.window(
  xlim = c(0.1, 1),
  xaxs = "i",
  ylim = c(10, 20),
  yaxs = "i",
  log = "x"
)

# Plot example data points using 
#   the secondary scaling
plot.xy(
  xy = xy.coords(
    x = c(0.15, 0.8),
    y = c(11, 19)
  ),
  type = "p",
  pch = 2
)

# Add the secondary y axis on the right side
#   of the plot region
Axis(side = 4)

# Draw a box around the plot region
box()

# Add axis labels
title(
  xlab = "x",
  ylab = "y"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

While the functions necessary to add appropriate axis labels and legends to this graph have not yet been discussed, detailed understanding of just a few scaling controls and lower level graphing functions add tremendous potential for creativity and informed troubleshooting.

The graphics parameters and graphical function arguments that control margins, limits on the plot region, and axis types together give complete control over canvas scaling. The ` xpd ` graphical parameter or graphical function argument allows subsequent control over whether plot region symbols are visible when they are placed at coordinates that are in the margins outside the plot region. 


## `r sec1`.`r sec2 <- sec2 + 1; sec3 <- 0; sec2`. Scaling the canvas for a multi-panel graph

A common need in data visualization is to align multiple graphs in a single figure to facilitate comparing patterns across different data sets relative to a common scale. Multiple graphs may also be grouped in the same figure simply because they have a common theme or represent a logical progression. Rendering multiple axes on a single device canvas is possible via several methods, depending on the flexibility needed for defining the size and location of each of the graphs. The ` mfrow ` or ` mfcol ` graphics parameter provide the simplest method, where the canvas inside the outer margins is divided evenly into a regularly spaced set of sub-canvases based on a user-defined number of rows and columns. The ` layout() ` function also creates a regularly spaced grid, but each sub-canvases can be arbitrarily assigned to take up any rectangular combination of those grid cells. This arbitrary assign creates a tremendous amount of flexibility in the size and shape of each graph in the figure. Finally, the most flexible method is to define the location of each graph manually by making repeated calls to the ` plot.window() ` function while varying the the location of the plot region with the ` mar ` or ` mai ` graphical parameters. This manual technique is less convenient in terms of the amount of code needed, but it is infinitely flexible regarding the size, shape, and location of each graph in the figure. Also, we have already covered all the graphics parameters, functions, and arguments necessary to create multi-panel graphs manually. The "simpler" methods require an understanding of additional graphing data structures and behavior.


### `r sec1`.`r sec2`.`r sec3 <- sec3 + 1; sec3` Creating multiple panels of arbitrary sizes and locations

Multiple panels can be created simply by recognizing that the plot region and scaling can be redefined repeatedly on the same canvas. The plot region can be moved by adjusting the ` mar ` or ` mai ` graphing parameter using ` par() ` function, and the scaling can be redefined by calling the ` plot.window() ` function with appropriate ` xlim ` and ` ylim ` arguments.

Let's experiment by creating two vertically stacked plots. First, we set the canvas height to 6 inches using the following chunk options.

` {r fig.width = 6, fig.height = 6, dev.args = list(pointsize = 12)} `

To create a plot in the upper half of this canvas, the bottom margin must be 4 inches to leave 3 inches for the bottom graph and 1 inch of space for the tick and axis labels of the top graph. Similarly, the plot in the lower half of this canvas needs a top margin of 3.2 inches to leave 3 inches for the top graph and 0.2 inches to be consistent with the space left at the top of the top graph. Calculating the margins (which could be done systematically with R code) is probably the most complicated aspect of manually crating multi-panel plots. 

```{r fig.width = 6, fig.height = 6, dev.args = list(pointsize = 12)}

# Initialize a new canvas
plot.new()

# Define margins for the upper graph
par(
  mai = c(4.0, 1.0, 0.2, 0.2)
)

# Scale the canvas
plot.window(
  xlim = c(0.5, 1.5),
  ylim = c(0.5, 1.5)
)

# Plot example data point
plot.xy(
  xy = xy.coords(
    x = 1,
    y = 1
  ),
  type = "p",
  pch = "1"
)

# Draw axes and box around plot region
Axis(side = 1)
Axis(side = 2)
box()

# Label axes
title(
  xlab = "x",
  ylab = "y"
)

# Define margins for the lower graph
par(
  mai = c(1.0, 1.0, 3.2, 0.2)
)

# Scale the canvas
plot.window(
  xlim = c(1.5, 2.5),
  ylim = c(1.5, 2.5)
)

# Plot example data point
plot.xy(
  xy = xy.coords(
    x = 2,
    y = 2
  ),
  type = "p",
  pch = "2"
)

# Draw axes and box around plot region
Axis(side = 1)
Axis(side = 2)
box()

# Label axes
title(
  xlab = "x",
  ylab = "y"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

Considering that the margins and scaling can be reset as many times as you wish as you add new graphs, your ability to organize multiple graphs on a canvas using this method is clearly only limited by your imagination.

Some convenience may be provided by recognizing that the graphics parameter ` new ` can be used to tell the device to prevent calls to ` plot ` or ` plot.new() ` from automatically advancing to the next canvas. By default, the ` new ` parameter is set to ` FALSE `, which means that calls to ` plot.new() ` (whether direct or indirect) will tell the device to advance to the next canvas.

```{r}
par("new")
```

Description of functions and arguments being used for the first time:

- ` par() `: Allows the values of graphical parameters associated with the current open graphics device to be retrieved or altered. Calling ` par() ` with no arguments will provide the full list of available graphics parameters.
    - ` "new" `: The graphics parameter that determines whether calls to ` plot.new() ` will advance the device to the next canvas. A value of ` FALSE ` will result in advancing to a new canvas the next time ` plot.new() ` is called. A value of ` TRUE ` will result in ignoring the next call to ` plot.new() ` and remaining on the same canvas.
        
The ability to set ` new ` to true in order to stay on the same canvas allows us to reproduce the previous example with substantially fewer lines of code.

```{r fig.width = 6, fig.height = 6, dev.args = list(pointsize = 12)}

# Define margins for upper graph
par(
  mai = c(4.0, 1.0, 0.2, 0.2)
)

# Plot example data point
plot(
  x = 1,
  xlim = c(0.5, 1.5),
  xlab = "x",
  y = 1,
  ylim = c(0.5, 1.5),
  ylab = "y",
  pch = "1"
)

# Define margins for lower graph
# Ignore next call to plot.new()
par(
  mai = c(1.0, 1.0, 3.2, 0.2),
  new = TRUE
)

# Plot example data point
plot(
  x = 2,
  xlim = c(1.5, 2.5),
  xlab = "x",
  y = 2,
  ylim = c(1.5, 2.5),
  ylab = "y",
  pch = "2"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

While this method of organizing multiple graphs on the same canvas is not common, it basically has no limits in regards to defining the size and location of each graph (other than those imposed by the pixel resolution of your graphing device). That said, simpler methods are available if distributing graphs across the canvas evenly, though they require understanding of additional syntax and behavior.


### `r sec1`.`r sec2`.`r sec3 <- sec3 + 1; sec3` Creating gridded panels using graphics parameters 

The graphical parameters ` mfrow ` and ` mfcol ` both define a regular grid of sub-canvases within the outer margins based on a number of rows and columns. These parameters should be a numerical or integer vector with two values representing rows first and columns second (the same order in which matrices are indexed in R). These vectors will always have the same value. However, setting these vectors using ` mfrow ` will result in the rows of the grid being filled before the columns, and setting these vectors using ` mfcol ` will result in the columns being filled before the rows.

By default, graphics parameters are configured with a single graph in mind. Therefore, the default vectors for ` mfrow ` and ` mfcol ` indicate one row and one column. 

```{r}
par("mfrow", "mfcol")
```

Description of functions and arguments being used for the first time:

- ` par() `: Allows the values of graphical parameters associated with the current open graphics device to be retrieved or altered. Calling ` par() ` with no arguments will provide the full list of available graphics parameters.
    - ` "mfrow", "mfcol" `: The graphics parameter controlling how many rows and columns are in a grid of sub-canvases within the outer margins. These vectors will always have the same value. Creating the grid using ` mfrow ` will result in the default order of graphing to fill rows before columns. Creating the grid using ` mfcol ` will result in the default order of graphing to fill columns before rows.

We can experiment with this method of creating sub-canvases by creating some graphs using an advancing numeric ` pch ` symbol to visualize the order of the rendering. Note that pch can use character strings as symbols. The grid of sub-canvases is created within the outer margins of the canvas, and we can experiment with the behavior of outer margins using the ` omi ` graphics parameter. Note that each time ` plot() ` is called, the new graph automatically advances to a new sub-canvas. This behavior is the result of the ` plot.default() ` function calling ` plot.new() `, which automatically advances the device to the next defined canvas or sub-canvas. If we set the rows and columns of the grid using ` mfrow `, then the rows will fill first.

Note that the aspect ratio of the canvas is being adjusted in Rmarkdown using the chunk parameters.

` {r fig.width = 6, fig.height = 8, dev.args = list(pointsize = 12)} `

```{r fig.width = 6, fig.height = 8, dev.args = list(pointsize = 12)}

# Divide space within outer margins into a grid
#   of sub-canvases with 3 rows and 2 columns
# Fill rows first
# Define outer margins around sub-canvases and
#   inner margins within each sub-canvas
par(
  mfrow = c(3, 2),
  omi = c(0.5, 0.5, 0.5, 0.5),
  mai = c(0.7, 0.7, 0.1, 0.1)
)

# Plot the first graph
plot(
  x = 1,
  xlab = "x",
  y = 1,
  ylab = "y",
  pch = "1"
)

# Draw a box around the sub-canvas
box(which = "figure")

# Plot the second graph
plot(
  x = 2,
  xlab = "x",
  y = 2,
  ylab = "y",
  pch = "2"
)

# Draw a box around the sub-canvas
box(which = "figure")

# Plot the third graph
plot(
  x = 3,
  xlab = "x",
  y = 3,
  ylab = "y",
  pch = "3"
)

# Draw a box around the sub-canvas
box(which = "figure")

# Plot the fourth graph
plot(
  x = 4,
  xlab = "x",
  y = 4,
  ylab = "y",
  pch = "4"
)

# Draw a box around the sub-canvas
box(which = "figure")

# Plot the fifth graph
plot(
  x = 5,
  xlab = "x",
  y = 5,
  ylab = "y",
  pch = "5"
)

# Draw a box around the sub-canvas
box(which = "figure")

# Plot the sixth graph
plot(
  x = 6,
  xlab = "x",
  y = 6,
  ylab = "y",
  pch = "6"
)

# Draw a box around the sub-canvas
box(which = "figure")

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

If we set the rows and columns of the grid using ` mfcol `, then the columns will fill first.

```{r fig.width = 6, fig.height = 8, dev.args = list(pointsize = 12)}

# Divide space within outer margins into a grid
#   of sub-canvases with 3 rows and 2 columns
# Fill columns first
# Define outer margins around sub-canvases and
#   inner margins within each sub-canvas
par(
  mfcol = c(3, 2),
  omi = c(0.5, 0.5, 0.5, 0.5),
  mai = c(0.7, 0.7, 0.1, 0.1)
)

# Plot the first graph
plot(
  x = 1,
  xlab = "x",
  y = 1,
  ylab = "y",
  pch = "1"
)

# Draw a box around the sub-canvas
box(which = "figure")

# Plot the second graph
plot(
  x = 2,
  xlab = "x",
  y = 2,
  ylab = "y",
  pch = "2"
)

# Draw a box around the sub-canvas
box(which = "figure")

# Plot the third graph
plot(
  x = 3,
  xlab = "x",
  y = 3,
  ylab = "y",
  pch = "3"
)

# Draw a box around the sub-canvas
box(which = "figure")

# Plot the fourth graph
plot(
  x = 4,
  xlab = "x",
  y = 4,
  ylab = "y",
  pch = "4"
)

# Draw a box around the sub-canvas
box(which = "figure")

# Plot the fifth graph
plot(
  x = 5,
  xlab = "x",
  y = 5,
  ylab = "y",
  pch = "5"
)

# Draw a box around the sub-canvas
box(which = "figure")

# Plot the sixth graph
plot(
  x = 6,
  xlab = "x",
  y = 6,
  ylab = "y",
  pch = "6"
)

# Draw a box around the sub-canvas
box(which = "figure")

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

Note that each sub-canvas in the grid is treated just like a full canvas with outer margins set to zero. The inner margins here are kept consistent, as is commonly desired in multi-paneled graphs. However, nothing is preventing you from calling ` par() ` to change the inner margins within each sub-canvas to resize each plot region. Every graphing element within each sub-canvas can be uniquely controlled as if it were a regular canvas, except that sub-canvases do not have outer margins.

The ` mfg ` graphics parameter keeps track of the grid cell to which graphics are currently being rendered. Let's assign the variable ` currentGridElement ` to the value value of ` mfg ` after plotting the first two graphs in the previous example.

```{r fig.width = 6, fig.height = 8, dev.args = list(pointsize = 12)}

# Define multi-panel grid and margins 
par(
  mfcol = c(3, 2),
  omi = c(0.5, 0.5, 0.5, 0.5),
  mai = c(0.7, 0.7, 0.1, 0.1)
)

# Plot the first graph
plot(
  x = 1,
  xlab = "x",
  y = 1,
  ylab = "y",
  pch = "1"
)

# Draw a box around the sub-canvas
box(which = "figure")

# Plot the second graph
plot(
  x = 2,
  xlab = "x",
  y = 2,
  ylab = "y",
  pch = "2"
)

# Draw a box around the sub-canvas
box(which = "figure")

# Get the row and column of the current grid element
currentGridElement <- par("mfg")

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

```{r}
currentGridElement
```

The first two elements of this ` mfg ` vector indicate that graphics are currently being rendered in the grid element located at the second row and the first column. If present, the third and fourth elements of the ` mfg ` vector specify the total number of rows and columns in the grid, though these elements do not need to be provided when setting ` mfg `.

Graphics elements can be added to any of the existing sub-canvases by setting the ` mfg ` graphics parameter to specify the appropriate grid element, including the sub-canvases that already have graphs. However, care should be taken that the scaling configuration is appropriate before adding elements to an existing graph. For example, we can plot a "4" at the coordinates x = 4, y = 4 in the sub-canvas in row three and column 1. To be sure the scaling is appropriate, we have to make sure that the current scaling configuration matches the scaling of the original graph. Recall that if the margins do not change, scaling is within our control by setting the ` xlim ` and ` ylim ` arguments when calling ` plot() ` or ` plot.window() `. Therefore, the scaling will be the same if the ` xlim ` and ` ylim ` arguments to ` plot() ` are the same (again, assuming the inner margins have not changed).

```{r fig.width = 6, fig.height = 8, dev.args = list(pointsize = 12)}

# Define multi-panel grid and margins 
par(
  mfcol = c(3, 2),
  omi = c(0.5, 0.5, 0.5, 0.5),
  mai = c(0.7, 0.7, 0.1, 0.1)
)

# Plot the first graph
plot(
  x = 1,
  xlab = "x",
  y = 1,
  ylab = "y",
  pch = "1"
)

# Draw a box around the sub-canvas
box(which = "figure")

# Plot the second graph
plot(
  x = 2,
  xlab = "x",
  y = 2,
  ylab = "y",
  pch = "2"
)

# Draw a box around the sub-canvas
box(which = "figure")

# Plot the third graph
plot(
  x = 3,
  xlim = c(1.8, 4.2),
  xlab = "x",
  y = 3,
  ylim = c(1.8, 4.2),
  ylab = "y",
  pch = "3"
)

# Draw a box around the sub-canvas
box(which = "figure")

# Plot the fourth graph
plot(
  x = 4,
  xlab = "x",
  y = 4,
  ylab = "y",
  pch = "4"
)

# Draw a box around the sub-canvas
box(which = "figure")

# Plot the fifth graph
plot(
  x = 5,
  xlab = "x",
  y = 5,
  ylab = "y",
  pch = "5"
)

# Draw a box around the sub-canvas
box(which = "figure")

# Plot the sixth graph
plot(
  x = 6,
  xlab = "x",
  y = 6,
  ylab = "y",
  pch = "6"
)

# Draw a box around the sub-canvas
box(which = "figure")

# Define the next multi-panel grid element
#   for rendering graphics elements
par(mfg = c(3, 1))

# Plot a graph with an additional
#   example data point
plot(
  x = 4,
  xlim = c(1.8, 4.2),
  xlab = "x",
  y = 4,
  ylim = c(1.8, 4.2),
  ylab = "y",
  pch = "4"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

Changing the value of ` mfg ` to a sub-canvas with an existing graph does not change the current values for the inner margins or the current scaling configuration. If the margins or scaling in the existing graph do not match those of the previous canvas (i.e. the value of ` mfg ` before being changed), then the ` mar ` or ` mai ` graphics parameter may need to be adjusted and the function ` plot.window() ` may need to be called with adjusted ` xlim ` and ` ylim ` arguments. To illustrate, let's remake the previous example using a call to ` plot.xy() `. In this case, we are using ` plot.xy() ` to place a "4" on the existing axes on the sub-canvas at the third row and first column, rather than using ` plot() ` to also completely remake the axes and labels. All the graphs have different scaling, so we need to return to the original scaling by calling ` plot.window() ` with matching ` xlim ` and ` ylim ` arguments. We do not need to reset the inner margins because all the graphs were originally created with the same plot region.

```{r fig.width = 6, fig.height = 8, dev.args = list(pointsize = 12)}

# Define multi-panel grid and margins 
par(
  mfcol = c(3, 2),
  omi = c(0.5, 0.5, 0.5, 0.5),
  mai = c(0.7, 0.7, 0.1, 0.1)
)

# Plot the first graph
plot(
  x = 1,
  xlab = "x",
  y = 1,
  ylab = "y",
  pch = "1"
)

# Draw a box around the sub-canvas
box(which = "figure")

# Plot the second graph
plot(
  x = 2,
  xlab = "x",
  y = 2,
  ylab = "y",
  pch = "2"
)

# Draw a box around the sub-canvas
box(which = "figure")

# Plot the third graph
plot(
  x = 3,
  xlim = c(1.8, 4.2),
  xlab = "x",
  y = 3,
  ylim = c(1.8, 4.2),
  ylab = "y",
  pch = "3"
)

# Draw a box around the sub-canvas
box(which = "figure")

# Plot the fourth graph
plot(
  x = 4,
  xlab = "x",
  y = 4,
  ylab = "y",
  pch = "4"
)

# Draw a box around the sub-canvas
box(which = "figure")

# Plot the fifth graph
plot(
  x = 5,
  xlab = "x",
  y = 5,
  ylab = "y",
  pch = "5"
)

# Draw a box around the sub-canvas
box(which = "figure")

# Plot the sixth graph
plot(
  x = 6,
  xlab = "x",
  y = 6,
  ylab = "y",
  pch = "6"
)

# Draw a box around the sub-canvas
box(which = "figure")

# Define the next multi-panel grid element
#   for rendering graphics elements
par(mfg = c(3, 1))

# Scale the canvas
plot.window(
  xlim = c(1.8, 4.2),
  ylim = c(1.8, 4.2)
)

# Plot an additional example data point
plot.xy(
  xy = xy.coords(
    x = 4,
    y = 4
  ),
  type = "p",
  pch = "4"
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```


### `r sec1`.`r sec2`.`r sec3 <- sec3 + 1; sec3` Others?

- ` layout() `
- ` split.screen() `


# `r sec1 <- sec1 + 1; sec2 <- 0; sec1`. Customizing axes

High level functions like ` plot.default() ` provide few features for direct control over formatting the axes. One strategy is to disable the axes when calling ` plot() `, then call ` Axis() ` directly to make use of all the features inaccessible via ` plot.default() `. Note that ` Axis() ` is an S3 abstraction, such that the function it actually calls depends on the arguments ` x ` and ` at ` passed to ` Axis `. When plotting axes based on numeric vectors, the function actually called is ` axis() `. Note that R is case-sensitive, so ` Axis() ` is technically a different function than ` axis() ` (though they sometimes have the same result).

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Define margins 
par(
  omi = c(0, 0, 0, 0),
  mai = c(0.9, 0.9, 0.2, 0.2)
)

# Plot example data points without axes
plot(
  x = c(0, 1),
  xlab = "x",
  y = c(0, 1),
  ylab = "y",
  axes = FALSE
)

# Add an x axis
axis(side = 1)

# Add a y axis
axis(side = 2)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

Description of functions and arguments being used for the first time:

- ` plot() ` or ` plot.default() `: A high level function for creating a new plot with a single line of code. The function ` plot() ` is an S3 abstraction, which in this case results in a call to ` plot.default() `.
    - ` axes `: Logical value specifying if axes should be created
        - ` FALSE `: Specifies that axes should not be drawn
- ` axis() `: Renders the symbolism of an axis with labeled ticks
    - ` side `: An integer specifying the side of the plot region upon which to place the axis (1 = bottom, 2 = left, 3 = top, 4 = right)
        - ` 1 ` or ` 2 `: Call with 1 creates the x axis and call with 2 creates the y axis

Notice that the ` axes = FALSE ` argument for ` plot() ` also results in the lack of a box drawn around the plot region. This feature is a consequence of the default value of the ` frame.plot ` argument being set to the same value as the ` axes ` argument (i.e., default value of ` frame.plot = axes ` specified in the arguments to ` plot.default() `.

```{r}
args(plot.default)
```

At this point, the convenience of using ` plot() ` may cause more confusion than it is worth. Perhaps customization at this level calls for more step-by-step code based on the dissection of ` plot.default() ` reviewed earlier.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Define margins 
par(
  omi = c(0, 0, 0, 0),
  mai = c(0.9, 0.9, 0.2, 0.2)
)

# Initialize a new canvas and scale it
plot.new()
plot.window(
  xlim = c(0, 1),
  ylim = c(0, 1)
)

# Add axes
axis(side = 1)
axis(side = 2)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

The R base graphics package will often find an aesthetically pleasing style for the axes with default settings, but just a few arguments passed directly to the ` axis() ` function provide tremendous flexibility in formatting, including but not limited to: style and location of ticks and axis lines; style, location, and content of tick labels; and the location of axes relative to the plot region.


## `r sec1`.`r sec2 <- sec2 + 1; sec2`. Customizing tick locations

The ` axis() ` function allows ticks to be located anywhere along the axes by passing a numeric vector of tick locations to the ` at ` argument. Therefore, any function that returns a numeric vector can be used to provide tick locations. Because aesthetically pleasing ticks are often at regular intervals, the ` seq() ` function is a good candidate for defining tick locations. However, use of the ` c() ` function to manually define the location of each tick is also possible. Regardless of the method used to create the vector for tick locations, an axis line is rendered from the first to the last tick specified. Note these axis lines are redundant and only the ticks and tick labels are a visible consequence of calls to ` axis() ` if a box is drawn around the plot region. For now, a box will not be drawn around the plot region to clearly observe the behavior of the ` axis() ` function.

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Define margins
par(
  omi = c(0, 0, 0, 0),
  mai = c(0.9, 0.9, 0.2, 0.2)
)

# Initialize a new canvas and scale it
plot.new()
plot.window(
  xlim = c(0, 1),
  ylim = c(0, 1)
)

# Add an x axis with custom ticks
axis(
  side = 1,
  at = seq(from = 0.1, to = 0.9, by = 0.2)
)

# Add a y axis with custom ticks
axis(
  side = 2,
  at = c(0, 0.15, 0.4, 0.55, 0.85, 1)
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

Description of functions and arguments being used for the first time:

- ` axis() `: Renders the symbolism of an axis with labeled ticks
    - ` at `: A numeric vector specifying the locations of ticks
        - ` seq(from = 0.1, to = 0.9, by = 0.2) `: Generates a vector with a sequence of values at regular intervals for tick locations
        - ` c(0, 0.15, 0.4, 0.55, 0.85, 1) `: Generates a vector with directly specified values for tick locations
- ` seq() `: Creates a vector based on regular sequence of values
    - ` from `: A value for the beginning of the sequence
        - ` 0.1 `: Start the numerical sequence at 0.1
    - ` to `: A value for the end of the sequence
        - ` 0.9 `: End the numerical sequence at a value less than or equal to 0.9
    - ` by `: The interval between elements of the sequence
        - ` 0.2 `: Elements of the sequence should increment by 0.2 from the value at the beginning of the sequence

The ` axis() ` function will attempt to label the ticks based on the value specifying the tick location, if the formatting of the labels allow the labels to fit without overlap. Ticks will still be rendered where the labels do not fit, but the label will not be rendered. For example, several ticks are added to the y axis below, where only the lower-valued tick is labeled because the higher-valued tick is too close to allow a label to be rendered without overlap. The number of times the ` axis() ` function is called has no restrictions. The function might be called to draw attention to particular values of interest in a figure. For example, a tick is added at the value of 0.42 on the x axis below, to draw attention to and quantify this particular value on the graph. 

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Define margins
par(
  omi = c(0, 0, 0, 0),
  mai = c(0.9, 0.9, 0.2, 0.2)
)

# Initialize a new canvas and scale it
plot.new()
plot.window(
  xlim = c(0, 1),
  ylim = c(0, 1)
)

# Add an x axis with custom ticks
axis(
  side = 1,
  at = seq(from = 0.1, to = 0.9, by = 0.2)
)
axis(
  side = 1,
  at = 0.42
)

# Add a y axis with custom ticks
axis(
  side = 2,
  at = c(-0.18, 0, 0.15, 0.38, 0.4, 0.55, 0.65, 0.85, 0.88, 1)
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

The tick label for the x axis value at 0.42 fits on the axis based on the choice of the other tick labels. However, calling ` axis() ` (or any graphical rendering function) multiple times can create overlap of symbols, by design. Adjusting the location of tick labels to avoid overlap will be a later topic. Finally, the value of -0.18 was added as a tick location on the y axis. This tick is not visible because cropping outside the plot region applies to axes as it does to symbols representing data. In the case of an axis, cropping only applies to the boundaries of the plot region defined along that axis. In this case, the tick label at -0.18 is being cropped by the edge of the plot region specified by the buffer from y = 0. Setting the `xpd` argument to ` TRUE ` for the call to ` axis() ` will allow the cropped tick and associated axis line outside the plot region to be visible. 

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Define margins
par(
  omi = c(0, 0, 0, 0),
  mai = c(0.9, 0.9, 0.2, 0.2)
)

# Initialize a new canvas and scale it
plot.new()
plot.window(
  xlim = c(0, 1),
  ylim = c(0, 1)
)

# Add an x axis with custom ticks
axis(
  side = 1,
  at = seq(from = 0.1, to = 0.9, by = 0.2)
)
axis(
  side = 1,
  at = 0.42
)

# Add a y axis with custom ticks
axis(
  side = 2,
  at = c(-0.18, 0, 0.15, 0.38, 0.4, 0.55, 0.65, 0.85, 0.88, 1),
  xpd = TRUE
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

Description of functions and arguments being used for the first time:

- ` axis() `: Renders the symbolism of an axis with labeled ticks
    - ` xpd `: A logical value indicating whether plot region symbolism located at canvas coordinates in the margins outside the plot region should be visible (` TRUE `) or clipped (` FALSE `)
        - ` TRUE `: Results in the portions of the axis in the margins outside the plot region to be visible.

The function ` axis() ` only provides a tool for labeling the existing coordinate system on the canvas. The location of the plot region and scaling of the canvas are unaffected by calls to ` axis() `. Additional axes rendered on a different scale or plot region within the canvas would first require another call to ` plot.window() `.


## `r sec1`.`r sec2 <- sec2 + 1; sec2`. Customizing tick labels

The basic character of tick labels can be customized using arguments to the ` axis() ` function. Both the content and the location of ticks are adjustable from this function. Though only customizations with arguments to ` axis() ` are covered here, even more creativity with tick labels (e.g., partial rotation of text) is possible by suppressing the labeling of ticks by setting the ` labels ` argument to ` FALSE ` and labeling ticks manually using the ` text() ` function with the argument ` xpd ` set to ` TRUE `.

If the locations of ticks are specified with the ` at ` argument, tick labels can also be defined explicitly with a vector of values passed to the ` labels ` argument. The length of the vectors for the ` at ` and ` labels ` arguments should be the same. As an example, values from 0 to 1 representing fractions of a whole might be visualized as the corresponding percentages by changing the tick labels without changing the original coordinate system based on fractions. 

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Define margins 
par(
  omi = c(0, 0, 0, 0),
  mai = c(0.9, 0.9, 0.2, 0.2)
)

# Initialize a new canvas and scale it
plot.new()
plot.window(
  xlim = c(0, 1),
  ylim = c(0, 1)
)

# Add an x axis with custom tick labels
axis(
  side = 1,
  at = seq(from = 0, to = 1, by = 0.2),
  labels = seq(from = 0, to = 100, by = 20)
)

# Add a y axis with custom tick labels
axis(
  side = 2,
  at = seq(from = 0, to = 1, by = 0.2),
  labels = c("0%", "20%", "40%", "60%", "80%", "100%")
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```

Description of functions and arguments being used for the first time:

- ` axis() `: Renders the symbolism of an axis with labeled ticks
    - ` labels `: A vector of values specifying the labels for ticks. This argument can only be used if the locations of ticks are specified with the ` at ` argument, and the length of the vector of labels should match the length of the vector of tick locations.
        - ` seq(from = 0, to = 100, by = 20) `: Results in numeric tick labels corresponding to 0, 20, 40, 60, 80, and 100 percent
        - ` c("0%", "20%", "40%", "60%", "80%", "100%") `: Results in text tick labels corresponding to 0, 20, 40, 60, 80, and 100 percent, including the percent symbol
        
The automation of tick label generation is thus only limited by the imagination of how numerical or character vectors can be generated. However, the tick labels can always be hard coded to the exact symbolism desired with an explicitly defined vector of character strings. As with many of the labeling functions in R graphics, vectors of R expressions can also be used if mathematical notation is needed (see ` help(plotmath) `). Examples of using ` plotmath ` features are provided in later materials.


## `r sec1`.`r sec2 <- sec2 + 1; sec2`. Customizing axis locations

```{r fig.width = 6, fig.height = 5, dev.args = list(pointsize = 12)}

# Define margins 
par(
  omi = c(0, 0, 0, 0),
  mai = c(0.9, 1.8, 0.2, 0.2)
)

# Initialize a new canvas and scale it
plot.new()
plot.window(
  xlim = c(0, 1),
  ylim = c(0, 1)
)

# Add an x axis
axis(
  side = 1
)

# Add a y axis
axis(
  side = 2
)

# Plot example data points
plot.window(
  xlim = c(0, 2),
  ylim = c(0, 2)
)

# Add a secondary y axis to the margin on the left
#   edge of the plot region
axis(
  side = 2,
  line = 4
)

# Draw a box around the outer edge of the canvas
box(which = "outer")

```


# `r sec1 <- sec1 + 1; sec2 <- 0; sec1`. Plotting symbols representing data


# `r sec1 <- sec1 + 1; sec2 <- 0; sec1`. Labeling the graph
